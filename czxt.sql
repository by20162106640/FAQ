/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50622
Source Host           : localhost:3306
Source Database       : czxt

Target Server Type    : MYSQL
Target Server Version : 50622
File Encoding         : 65001

Date: 2020-03-15 12:54:17
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for djj
-- ----------------------------
DROP TABLE IF EXISTS `djj`;
CREATE TABLE `djj` (
  `did` int(11) NOT NULL,
  `question` varchar(0) NOT NULL,
  `uid` int(11) NOT NULL,
  PRIMARY KEY (`did`,`uid`),
  KEY `FK_user_djj` (`uid`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of djj
-- ----------------------------

-- ----------------------------
-- Table structure for gly
-- ----------------------------
DROP TABLE IF EXISTS `gly`;
CREATE TABLE `gly` (
  `gid` int(11) NOT NULL AUTO_INCREMENT,
  `password` varchar(32) DEFAULT NULL,
  `gname` varchar(200) NOT NULL,
  PRIMARY KEY (`gid`),
  UNIQUE KEY `AK_Key_2` (`gname`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of gly
-- ----------------------------
INSERT INTO `gly` VALUES ('1', '123456789', '希瑞');

-- ----------------------------
-- Table structure for question_answer
-- ----------------------------
DROP TABLE IF EXISTS `question_answer`;
CREATE TABLE `question_answer` (
  `qid` int(11) NOT NULL AUTO_INCREMENT,
  `question` varchar(500) DEFAULT NULL,
  `answer` varchar(1000) NOT NULL,
  `tid` int(11) DEFAULT NULL,
  PRIMARY KEY (`qid`),
  KEY `FK_teacher_question_answer` (`tid`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=313 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of question_answer
-- ----------------------------
INSERT INTO `question_answer` VALUES ('1', '设计现代OS的主要目标是什么?', '其主要目标是有效性、方便性、可扩充性、开放性。', '0');
INSERT INTO `question_answer` VALUES ('2', 'OS的作用可表现在哪几个方面?', '1、OS作为用户与计算机硬件系统之间的接口；\r\n2、OS作为计算机资源的管理者；\r\n3、OS实现了对计算机资源的抽象；', '0');
INSERT INTO `question_answer` VALUES ('3', '为什么说操作系统实现了对计算机资源的抽象?', 'OS是铺设在计算机硬件上的多层系统软件,它们不仅增强了系统的功能，而且还隐藏了对硬件操作的细节,由它们实现了对计算机硬件操作的多个层次的抽象。值得说明的,对一个硬件在底层进行抽象后,在高层还可再次对该资源进行抽象,成为更高层的抽象模型.随着抽象层次的提高,抽象接口所提供的功能就越来越强,用户使用起来也更加方便。', '0');
INSERT INTO `question_answer` VALUES ('4', '试说明推动多道批处理系统形成和发展的主要动力是什么?', '为了进一步提高资源的利用率和系统吞吐量,在该系统中,用户所提交的作业都先存放在外存上并排成一个队列,称为“后备队列”；然后,由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存,使它们共享CPU和系统中各种资源。在OS中引入多道程序设计技术可带来以下好处:提高CPU和利用率、可提高内存和I/0设备利用率、增加系统吞吐量。主要动力:1、不断提高计算机资源的利用率；2.方便用户；3、器件的不断更新换代；4.计算机体系结构的不断发展。', '0');
INSERT INTO `question_answer` VALUES ('5', '何谓脱机I/O和联机I/O?', '脱机I/0方式:由于程序和数据的输入和输出都是在外围机的控制下完成的,或者说,它们是在脱离主机的情况下进行的,故称为脱机输入/输出方式.\r\n联机I/0方式:在主机的直接控制下进行输入/输出的方式称为联机输入/输出方式.', '0');
INSERT INTO `question_answer` VALUES ('6', '试说明推动分时系统形成和发展的主要动力是什么?', '分时系统它能很好的将一台计算机提供给多个用户同时使用，提高计算机的利用率。1、人—机交互；2、共享主机；3、便于用户上机。', '0');
INSERT INTO `question_answer` VALUES ('7', '实现分时系统的关键问题是什么?应如何解决?', '其最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端键入命令时，系统应能及时接收并及时处理该命令，再将结果返回给用户。用户可继续键入下一条命令，此即人—机交互。应强调指出，即使有多个用户同时通过自己的键盘键入命令，系统也能全部地及时接收并处理这些命令。1、及时接收；2、及时处理；', '0');
INSERT INTO `question_answer` VALUES ('8', '为什么要引入实时操作系统?', '实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。1、应用需求；2、实时任务；', '0');
INSERT INTO `question_answer` VALUES ('9', '什么是硬实时任务和软实时任务?', '硬实时任务是系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。软实时任务是它也联系着一个截止时间，但并不严格，若偶而错过了任务的截止时间，对系统产生的影响也不会太大。', '0');
INSERT INTO `question_answer` VALUES ('10', '试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较?', '（1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100微妙。\r\n（2）交互性：实时信息处理系统具有交互性，但人与系统的交互仅限于访问系统中某些特定的专用服务程序。不像分时系统那样能向终端用户提供数据和资源共享等服务。\r\n（3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。', '0');
INSERT INTO `question_answer` VALUES ('11', 'OS有哪几大特征?其最基本的特征是什么?', '并发性、共享性、虚拟性和异步性四个基本特征；最基本的特征是并发性。', '0');
INSERT INTO `question_answer` VALUES ('12', '是什么原因使操作系统具有异步性特征?', '进程是以人们不可预知的速度向前推进，此即进程的异步性。', '0');
INSERT INTO `question_answer` VALUES ('13', '设备管理有哪些主要功能?其主要任务是什么?', '主要任务是:完成用户进程提出的I/0请求;为用户进程分配其所需的I/O设备;提高CPU和I/0设备的利用率;提高I/0速度;方便用户使用I/0设备.有缓冲管理、设备分配和设备处理以及虚拟设备等功能。1、缓冲管理:在I/0设备和CPU之间引入缓冲,提高CPU 的利用率,进而提高系统吞吐量.在现代计算机系统中,都无一例外地在内存中设置了缓冲区,而且还可通过增加缓冲区容量的方法来改善系统的性能.对于不同的系统,可以采用不同的缓冲区机制。\r\n2、设备分配:设备分配的基本任务是根据用户进程的I/O 请求、系统的现有资源情况以及按照某种设备的分配策略,为之分配其所需的设备。如果在I/O设备和CPU之间还存在着设备控制器和I/O通道时,还须为分配出去的设备分配相应的控制器和通道。\r\n3、设备处理:设备处理程序又称为设备驱动程序。其基本任务是用于实现CPU和设备控制器之间的通信,即由CPU 向设备控制器发出I/O命令,要求它完成指定的I/O操作;反之,由CPU 接收从控制器发来的中断请求,并给予迅速的响应和相应的处理.', '0');
INSERT INTO `question_answer` VALUES ('14', '文件管理有哪些主要功能?其主要任务是什么?', '文件管理的主要任务是对用户文件和系统文件进行管理,以方便用户使用,并保证文件的安全性。为此,文件存储空间的管理、目录管理、文件的读/写管理,以及文件的共享与保护等功能。1、文件存储空间的管理:其主要任务是为每个文件分配必要的外存空间,提高外存的利用率,并能有助于提高文件系统的存、取速度。2,目录管理:目录管理的主要任务是为毎个文件建立其目录项,并对众多的目录项加以有效的组织,以实现方便的按名存取,即用户只须提供文件名便可对该文件进行存取.3、文件的读/写管理和保护:文件的读/写管理其该功能是根据用户的请求,从外存中读取数据,或将数据写入外存。文件保护其为了防止系统中的文件被非法窃取和破坏,在文件系统中必须提供有效的存取控制功能。', '0');
INSERT INTO `question_answer` VALUES ('15', '什么是微内核OS?', '1、足够小的内核。2、基于客户/服务器模式。3、应用“机制与策略分离”原理。4、采用面向对象技术。', '0');
INSERT INTO `question_answer` VALUES ('16', '微内核操作系统具有哪些优点?', '1、提高了系统的可延展性。2、增强了系统的可靠性。3、可移植性。4、提供了对分布式系统的支持。5、融入了面向对象技术', '0');
INSERT INTO `question_answer` VALUES ('17', '在微内核OS中,为什么要采用客户/服务器模式?', 'C/S 模式具有独特的优点：⑴数据的分布处理和存储。\r\n⑵便于集中管理。\r\n⑶灵活性和可扩充性。\r\n⑷易于改编应用软件', '0');
INSERT INTO `question_answer` VALUES ('18', '在基于微内核结构的OS中,应用了哪些新技术?', '面向对象技术', '0');
INSERT INTO `question_answer` VALUES ('19', '何谓微内核技术?在微内核中通常提供了哪些功能?', '把操作系统中更多的成分和功能放到更高的层次（即用户模式）中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。在微内核中通常提供了进程（线程）管理、低级存储器管理、中断和陷入处理等功能。', '0');
INSERT INTO `question_answer` VALUES ('20', '在多道程序技术的 OS 环境下的资源共享与一般情况下的资源共享有何不同?对独占资源应采取何种共享方式?', '一般情况下的共享只是说明某种资源能被大家使用，例如图书馆的图书能提供给大家借阅。对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理比较简单；', '0');
INSERT INTO `question_answer` VALUES ('21', '什么是时分复用技术?', '就是有N个信号源要传输给N个目的地（所谓n channels)，但是只有一个传输通道（link）给他们使用，所以大家怎么分这个link的问题。这种分享就叫multiplexing. TDM就是multiplexing的方式。', '0');
INSERT INTO `question_answer` VALUES ('22', '处理机管理有哪些主要功能?其主要任务是什么?', '处理机管理的主要功能是：进程管理、进程同步、进程通信和处理机调度。主要任务： 是对处理机进行分配， 并对其运行进行有效控制和管\r\n理。 在多道程序环境下， 处理机的分配和运行都是以进程为基本\r\n单位。', '0');
INSERT INTO `question_answer` VALUES ('23', '内存管理有哪些主要功能?其主要任务是什么?', '\n\n内存管理的主要功能有内存分配、 内存保护、 地址映射和内存扩充。 内存分配： a. 道程序分配内存空间 b. 存储器的利用率 c. 运行的程序申请附加的内存空间。 内存保护： a. 确保每道用户程序都仅在自己的内存空间内运行， 彼此互不打扰 b. 决不允许用户程序访问程序访问操作系统的程序和数据， 也不允许用户程序转移到非共享的其它用户程序中去执行。 地址映射： 将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。 内存扩充： 用于实现请求调入功能和置换功能。', '0');
INSERT INTO `question_answer` VALUES ('24', '试说明推动传统OS演变为现代OS的主要因素是什么?', '在微内核操作系统中,内核是指精心设计的、能实现现代OS最基本核心功能。', '0');
INSERT INTO `question_answer` VALUES ('25', '什么是前趋图?为什么要引入前趋图?', ' 前趋图(Precedence Graph) 是一个有向无循环图， 记为DAG(Directed AcyclicGraph) ， 用于描述进程\r\n之间执行的前后关系。', '0');
INSERT INTO `question_answer` VALUES ('26', '为什么程序并发执行会产生间断性特征?', '程序在并发执行时， 是多个程序共享系统中的各种资源， 因而这些资源的状态将由多个程序来\r\n改变， 致使程序的运行已失去了 封闭性。 同时由于失去了 封闭性， 也将导致其再失去可再现性。 程序在并\r\n发执行时， 由于失去了 封闭性， 程序经过多次执行后， 其计算机结果已与并发程序的执行速度有关， 从而\r\n使程序的执行失去了可再现性。', '0');
INSERT INTO `question_answer` VALUES ('27', '程序并发执行时为什么会失去封闭性和可再现性?', '程序在并发执行时， 是多个程序共享系统中的各种资源， 因而这些资源的状态将由多个程序来\r\n改变， 致使程序的运行已失去了 封闭性。 同时由于失去了 封闭性， 也将导致其再失去可再现性。 程序在并\r\n发执行时， 由于失去了 封闭性， 程序经过多次执行后， 其计算机结果已与并发程序的执行速度有关， 从而\r\n使程序的执行失去了可再现性。', '0');
INSERT INTO `question_answer` VALUES ('28', '在操作系统中为什么要引入进程的概念?它会产生什么样的影响?', '在操作系统中引入进程的概念， 是为了 实现多个程序的并发执行。 传统的程序不能与其他程序并发执\r\n行， 只有在为之创建进程后， 才能与其他程序（进程） 并发执行。 这是因为并发执行的程序（即进程） 是\r\n“停停走走” 地执行， 只有在为它创建进程后， 在它停下时， 方能将其现场信息保存在它的 PCB 中， 待下\r\n次被调度执行是， 再从 PCB 中恢复 CPU 现场并继续执行， 而传统的程序却无法满足上述要求。\r\n建立进程所带来的好处是使多个程序能并发执行， 这极大地提高了 资源利用率和系统吞吐量。 但管理\r\n进程也需付出一定的代价， 包括进程控制块及协调各运行机构所占用的内存空间开销， 以及为进行进程间\r\n的切换、 同步及通信等所付出的时间开销。', '0');
INSERT INTO `question_answer` VALUES ('29', '从动态性、并发性和独立性上比较进程和程序有什么不同?', '（1） 动态性： 进程既然是进程实体的执行过程， 因此， 动态性是进程最基本的特性。 动态性还表现为：\r\n“它由创建而产生， 由调度而执行， 因得不到资源而暂停执行， 以及由撤消而消亡”。 可见， 进程有一定的\r\n生命期。 而程序只是一组有序指令的集合， 并存放在某种介质上， 本身并无运动的含义， 因此， 程序是个\r\n静态实体。\r\n（2） 并发性： 所谓进程的并发， 指的是多个进程实体， 同存于内存中， 能在一段时间内同时运行。 并\r\n发性是进程的重要特征， 同时也成为 OS 的重要特征。 引入进程的目的也正是为了使其程序能和其它进程的\r\n程序并发执行， 而程序是无法并发执行的。\r\n（3） 独立性： 进程实体是一个能独立运行的基本单位， 也是系统中独立获得资源和独立调度的基本单\r\n位。 凡未建立进程的程序， 都不能作为一个独立的单位参加运行。', '0');
INSERT INTO `question_answer` VALUES ('30', '试说明PCB 的作用具体表现在哪几个方面,为什么说PCB是进程存在的唯一标志?', ' PCB 是进程实体的一部分， 是 OS 中最重要的记录型数据结构。 它记录了 OS 所需的、 用于描述进\r\n程情况及控制进程运行所需的全部信息。 PCB 的作用， 是使一个在多道程序环境下不能独立运行的程序（含\r\n数据） 成为一个能独立运行的基本单位， 一个能与其他进程并发执行的进程。 或者说， OS 是根据 PCB 来对\r\n并发执行的进程进行控制和管理的。\r\n在进程的整个生命期中， 系统总是通过 PCB 对进程进行控制， 也就是说， 系统是根据进程的 PCB 感知\r\n到该进程的存在的， 所以说， PCB 是进程存在的标志。', '0');
INSERT INTO `question_answer` VALUES ('31', 'PCB提供了进程管理和进程调度所需要的哪些信息?', '进程管理：通用寄存器，指令计数器，程序状态字，用户栈指针，中的内容组成的。 进程调度：进程状态，进程优先数（级/权），等待原因，调度算法参数', '0');
INSERT INTO `question_answer` VALUES ('32', '进程控制块的组织方式有哪几种?', '1）线性表方式：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。\n2）索引表方式：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。\n3）链接表方式：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。', '0');
INSERT INTO `question_answer` VALUES ('33', '何谓操作系统内核?内核的主要功能是什么?', '操作系统（英语：Operating System，简称OS）是管理计算机硬件与软件资源的程序，同时也是计算机系统的核心与基石。操作系统身负诸如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作接口。 操作系统的形态非常多样，不同机器安装的操作系统可从简单到复杂，可从手机的嵌入式系统到超级计算机的大型操作系统。许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用文字接口，而将图形接口视为一种非必要的应用程序。\r\n 把操作系统中更多的成分和功能放到更高的层次(即用户模式) 中去运行， 而留下一个尽量小的内核，\r\n用它来完成操作系统最基本的核心功能， 称这种技术为微内核技术。 在微内核中通常提供了进程(线程) 管\r\n理、 低级存储器管理、 中断和陷入处理等功能。', '0');
INSERT INTO `question_answer` VALUES ('34', '进程在三个基本状态之间转换的典型原因是什么?', '（1） 处于就绪状态的进程， 当进程调度程序为之分配了处理机后， 该进程就由就绪状态变为执行状态\r\n（2） 正在执行的进程因发生某事件而无法执行， 如暂时无法取得所需资源， 则由执行状态转变为阻塞\r\n状态。\r\n（3） 正在执行的进程， 如因时间片用完或被高优先级的进程抢占处理机而被暂停执行， 该进程便由执\r\n行转变为就绪状态。', '0');
INSERT INTO `question_answer` VALUES ('35', '为什么要引入挂起状态?该状态有哪些性质?', '引入挂起状态的原因:(1)终端用户的请求。(2)父进程请求。(3)负荷调节的需要。(4)操作系统需要。处于挂起状态的进程最大的特点是主动放弃CPU调度。引入挂起状态后,进程状态转换图中增加了活动阻塞、静止阻塞、活动就绪、静止就绪四个状态,并增加了活动就绪与静止就绪之间的相互转换,活动阻塞与静止阻塞之间的相互转换。', '0');
INSERT INTO `question_answer` VALUES ('36', '在进行进程切换时,所要保存的处理机状态信息有哪些?', '保存的处理机状态信息主要由处理机中的各种寄存器内容组成。 这些寄存器包括： 通用寄存器，\r\n指令寄存器， 程序状态字 PSW， 用户栈指针。', '0');
INSERT INTO `question_answer` VALUES ('37', '引起进程创建的主要事件是什么?', '（1） 用户登录 在分时系统中， 用户在终端键入登录命令后， 若是合法用户， 系统将为该终端用户建\r\n立一个进程， 并插入到就绪队列中。\r\n（2） 作业调度 批处理程序中， 作业调度程序按一定的算法调度到某个作业时， 就将该作业装入内存，\r\n为它分配必要的资源， 并立即为其创建进程， 插入就绪队列中。\r\n（3） 提供服务 运行中用户程序提出某种请求， 系统专门创建一个进程来提供用户所需服务。\r\n（4） 应用请求 应用进程自己创建一个进程， 使自己和新进程以并发运行方式完成特定任务。', '0');
INSERT INTO `question_answer` VALUES ('38', '引起进程被撤消的主要事件是什么?', '引起进程被撤销的主要事件有： 正常结束、 异常结束(越界错误、 保护错、 非法指令、 特权指令错、 运\r\n行超时、 等待超时、 算术运算错、 I/O 故障) 、 外界干预(操作员或操作系统干预、 父进程请求、 父进程终\r\n止) 。', '0');
INSERT INTO `question_answer` VALUES ('39', '在创建一个进程时所要完成的主要工作是什么?', '（1） 申请空白 PCB ；\r\n（2） 为新进程分配资源；\r\n（3） 初始化 PCB ， 其中包括：\r\n 初始化标识符信息。 将系统分配的标识符、 父进程标识符填入新 PCB 中；\r\n 初始化处理机状态信息。 使程序计数器指向程序入口地址， 使栈指针指向栈顶；\r\n 初始化处理机控制信息。 将进程状态设置为就绪或静止就绪， 对于优先级通常设置为最\r\n低， 除非用户提出高优先级要求。\r\n（4） 将新进程插入就绪队列。', '0');
INSERT INTO `question_answer` VALUES ('40', '在撤消一个进程时所要完成的主要工作是什么?', '(1) 根据被终止进程标识符， 从PCB 集中检索出进程PCB， 读出该进程状态。 (2) 若被终止进程处于执行\r\n状态， 立即终止该进程的执行， 置调度标志真， 指示该进程被终止后重新调度。 (3) 若该进程还有子进程，\r\n应将所有子孙进程终止， 以防它们成为不可控进程。 (4) 将被终止进程拥有的全部资源， 归还给父进程， 或\r\n归还给系统。 (5) 将被终止进程PCB 从所在队列或列表中移出， 等待其它程序搜集信息。', '0');
INSERT INTO `question_answer` VALUES ('41', '引起进程阻塞或被唤醒的主要事件是什么?', ' a. 请求系统服务； b. 启动某种操作； c. 新数据尚未到达； d. 无新工作可做.', '0');
INSERT INTO `question_answer` VALUES ('42', '为什么要在OS中引入线程?', '为了使程序在多道程序环境下能并发执行， 并对并发执行的程序加以控制和描述， 在操作系统中引入\r\n在操作系统中引入线程， 则是为了减少程序在并发执行时所付出的时空开销， 使OS具有更好的并发性，\r\n提高CPU的利用率。 进程是分配资源的基本单位, 而线程则是系统调度的基本单位。', '0');
INSERT INTO `question_answer` VALUES ('43', '线程具有哪些属性?', ' (1) 轻型实体(2) 独立调度和分派的基本单位(3) 可并发执行(4) 共享进程资源。', '0');
INSERT INTO `question_answer` VALUES ('44', '线程控制块TCB中包含了哪些内容?', '一般 TCB 中的内容较少， 因为有关资源分配等多数信息已经记录于所属进程的 PCB\r\n中． TCB 中的主要信息包括线程标识、 线程状态、 调度参数、 现场、 链接指针， 其中现\r\n场信息主要包括通用寄存器、 指令计数器 PC 以及用户栈指针． 对于操作系统支持的线\r\n程， TCB 中还应包含系统栈指针。', '0');
INSERT INTO `question_answer` VALUES ('45', '何谓用户级线程和内核支持线程?', '(1) 用户级线程： 仅存在于用户空间中的线程， 无须内核支持。 这种线程的创建、 撤销、 线程间的同步\r\n与通信等功能， 都无需利用系统调用实现。 用户级线程的切换通常发生在一个应用进程的诸多线程之间，\r\n同样无需内核支持。 (2) 内核支持线程： 在内核支持下运行的线程。 无论是用户进程中的线程， 还是系统线\r\n程中的线程， 其创建、 撤销和切换等都是依靠内核， 在内核空间中实现的。 在内核空间里还为每个内核支\r\n持线程设置了线程控制块， 内核根据该控制块感知某线程的存在并实施控制。', '0');
INSERT INTO `question_answer` VALUES ('46', '用户级线程的实现方法是什么?', '用户级线程是在用户空间中的实现的， 运行在“运行时系统” 与“内核控制线程” 的中间系统上。 运\r\n行时系统用于管理和控制线程的函数的集合。 内核控制线程或轻型进程LWP可通过系统调用获得内核提供服\r\n务， 利用LWP进程作为中间系统。', '0');
INSERT INTO `question_answer` VALUES ('47', '内核支持线程的实现方法是什么?', ' 系统在创建新进程时， 分配一个任务数据区PTDA， 其中包括若干个线程控制块TCB空间。 创建一个线程\r\n分配一个TCB， 有关信息写入TCB， 为之分配必要的资源。 当PTDA中的TCB 用完， 而进程又有新线程时， 只\r\n要所创建的线程数目未超过系统允许值， 系统可在为之分配新的TCB； 在撤销一个线程时， 也应回收线程的\r\n所有资源和TCB。', '0');
INSERT INTO `question_answer` VALUES ('48', '多线程模型有哪几种类型?多对一模型有何优缺点?', '用户线程模型\r\n内核线程模型\r\n混合线程模型', '0');
INSERT INTO `question_answer` VALUES ('49', '高级调度与低级调度的主要任务是什么? 为什么要引入中级调度?', '高级调度的主要任务是根据某种算法， 把外存上处于后备队列中的那些作业调入内存。 低级调度是保\r\n存处理机的现场信息， 按某种算法先取进程， 再把处理器分配给进程。 引入中级调度的主要目的是为了提\r\n高内存利用率和系统吞吐量。 使那些暂时不能运行的进程不再占用内存资源， 将它们调至外存等待， 把进\r\n程状态改为就绪驻外存状态或挂起状态。', '0');
INSERT INTO `question_answer` VALUES ('50', '处理机调度算法的共同目标是什么?批处理系统的调度目标又是什么?', '处理机调度算法的共同目标：资源利用率，公平性，平衡性，策略强制执行。\r\n批处理系统的共同目标：平均周转时间短，系统吞吐量高，处理机利用率高', '0');
INSERT INTO `question_answer` VALUES ('51', '何谓作业、作业步和作业流?', '作业包含通常的程序和数据， 还配有作业说明书。 系统根据该说明书对程序的运行进行控制。 批处理\r\n系统中是以作业为基本单位从外存调入内存。 作业步是指每个作业运行期间都必须经过若干个相对独立相\r\n互关联的顺序加工的步骤。 作业流是指若干个作业进入系统后依次存放在外存上形成的输入作业流； 在操\r\n作系统的控制下， 逐个作业进程处理， 于是形成了处理作业流。', '0');
INSERT INTO `question_answer` VALUES ('52', '在什么情况下需要使用作业控制块JCB,其中包含了哪些内容?', '每当作业进入系统时， 系统便为每个作业建立一个作业控制块JCB， 根据作业类型将它插入到相应的后\r\n备队列中。\r\nJCB 包含的内容通常有： 1) 作业标识2) 用户名称3) 用户账户4) 作业类型(CPU繁忙型、 I/O 芳名型、 批量型、\r\n终端型) 5) 作业状态6) 调度信息(优先级、 作业已运行) 7) 资源要求8) 进入系统时间9) 开始处理时间10) 作\r\n业完成时间11) 作业退出时间12) 资源使用情况等', '0');
INSERT INTO `question_answer` VALUES ('53', '在作业调度中应如何确定接纳多少个作业和接纳哪些作业?', '作业调度每次接纳进入内存的作业数， 取决于多道程序度。 应将哪些作业从外存调入内存， 取决于采用\r\n的调度算法。 最简单的是先来服务调度算法， 较常用的是短作业优先调度算法和基于作业优先级的调度算\r\n法。', '0');
INSERT INTO `question_answer` VALUES ('54', '为什么要引入高响应比优先调度算法? 它有何优点?', '高响应比优先调度算法的基本思想是把CPU分配给就绪队列中响应比最高的进程。 既考虑作业的执行时间也考虑作业的等待时间,综合了先来先服务和最短作业优先两种算法的特点。', '0');
INSERT INTO `question_answer` VALUES ('55', '低级调度的主要功能是什么?', '(1) 保存处理机的现场信息(2) 按某种算法选取进程(3) 把处理机分配给进程。', '0');
INSERT INTO `question_answer` VALUES ('56', '在抢占调度方式中,抢占的原则是什么?', ' 抢占的原则有： 时间片原则、 优先权原则、 短作业优先权原则等。', '0');
INSERT INTO `question_answer` VALUES ('57', '在选择调度方式和调度算法时,应遵循的准则是什么?', '(1) 面向用户的准则： 周转时间短、 响应时间快、 截止时间的保证、 优先权准则。 (2) 面向系统的准则：\r\n系统吞吐量高、 处理机利用率好、 各类资源的平衡利用。', '0');
INSERT INTO `question_answer` VALUES ('58', '在批处理系统,分时系统和实时系统中,各采用哪几种进程(作业)调度算法?', ' 批处理系统的调度算法： 短作业优先、 优先权、 高响应比优先、 多级反馈队列调度算法。\r\n分时系统的调度算法： 时间片轮转法。\r\n实时系统的调度算法： 最早截止时间优先即EDF、 最低松弛度优先即LLF算法。', '0');
INSERT INTO `question_answer` VALUES ('59', '何谓静态和动态优先级?确定静态优先级的依据是什么?', ' 静态优先级是指在创建进程时确定且在进程的整个运行期间保持不变的优先级。 动态优先级是指在创\r\n建进程时赋予的优先权， 可以随进程推进或随其等待时间增加而改变的优先级， 可以获得更好的调度性能。\r\n确定进程优先级的依据： 进程类型、 进程对资源的需求和用户要求。', '0');
INSERT INTO `question_answer` VALUES ('60', 'FCFS和SJF两种进程调度算法有哪些不同?', '相同点： 两种调度算法都可以用于作业调度和进程调度。\r\n不同点： FCFS调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业， 将它们调入内存、\r\n分配资源、 创建进程、 插入到就绪队列。 该算法有利于长作业/进程， 不利于短作业/进程。 SPF算法每次\r\n调度都从后备队列中选择一个或若干个估计运行时间最短的作业， 调入内存中运行。 该算法有利于短作\r\n业/进程， 不利于长作业/进程。', '0');
INSERT INTO `question_answer` VALUES ('61', '在时间片轮转法中,应如何确定时间片的大小?', ' 时间片应略大于一次典型的交互需要的时间。 一般应考虑三个因素： 系统对相应时间的要求、 就绪队\r\n列中进程的数目和系统的处理能力。', '0');
INSERT INTO `question_answer` VALUES ('62', '通过一个例子来说明通常的优先级调度算法为什么不能适用于实时系统?', '实时系统的调度算法很多， 主要是基于任务的开始截止时间和任务紧急/松弛程度的任务优先级调度算\r\n法， 通常的优先级调度算法不能满足实时系统的调度实时性要求而不适用。', '0');
INSERT INTO `question_answer` VALUES ('63', '为什么说多级反馈队列调度算法能较好地满足各方面用户的需要?', '(1) 终端型作业用户提交的作业大多属于较小的交互型作业， 系统只要使这些作业在第一队列规定的时\r\n间片内完成， 终端作业用户就会感到满足。\r\n(2) 短批处理作业用户， 开始时像终端型作业一样， 如果在第一队列中执行一个时间片段即可完成， 便\r\n可获得与终端作业一样的响应时间。 对于稍长作业， 通常只需在第二和第三队列各执行一时间\r\n片即可完成， 其周转时间仍然较短。\r\n(3) 长批处理作业， 它将依次在第1， 2， …， n个队列中运行， 然后再按轮转方式运行， 用户不必担心\r\n其作业长期得不到处理。 所以， 多级反馈队列调度算法能满足多用户需求。', '0');
INSERT INTO `question_answer` VALUES ('64', '为什么说传统的几种调度算法都不能算是公平调度算法?', '以上介绍的几种调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。', '0');
INSERT INTO `question_answer` VALUES ('65', '保证调度算法是如何做到调度的公平性的?', '以上介绍的几种调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。', '0');
INSERT INTO `question_answer` VALUES ('66', '公平分享调度算法又是如何做到调度的公平性的?', '在公平分享调度算法中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。', '0');
INSERT INTO `question_answer` VALUES ('67', '为什么在实时系统中,要求系统(尤其是CPU)具有较强的处理能力?', '实时系统中通常有着多个实时任务。 若处理机的处理能力不够强， 有可能因为处理机忙不过来而使某\r\n些实时任务得不到及时处理， 导致发生难以预料的后果。', '0');
INSERT INTO `question_answer` VALUES ('68', '按调度方式可将实时调度算法分为哪几种?', '非抢占式和抢占式。非抢占式又分为非抢占式轮转调度算法和非抢占式优先调度算法，抢占式又分为基于时钟中断的抢占式优先级调度算法和立即抢占的优先级调度算法。', '0');
INSERT INTO `question_answer` VALUES ('69', '什么是最早截止时间优先调度算法?', '根据任务的开始截止时间确定的任务优先级调度算法。截止时间越早则优先级越高。该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。', '0');
INSERT INTO `question_answer` VALUES ('70', '什么是最低松弛度优先调度算法?', '该算法是根据任务的紧急(或松弛)程度，来确定任务的优先级。任务的紧急程度越高，为该任务所赋予的优先级就越高，以使之优先执行。', '0');
INSERT INTO `question_answer` VALUES ('71', '何谓“优先级倒置”现象,可采取什么方法来解决?', '当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。', '0');
INSERT INTO `question_answer` VALUES ('72', '可重用资源和可消耗资源的性质是什么?', '可重用性资源： 每一个可重用性资源中的单元只能分配给一个进程使用， 不\r\n允许多个进程共享。进程在使用可重用性资源时， 须按照这样的顺序： 请求资源、\r\n使用资源、 释放资源。 系统中每一类可重用性资源中的单元数口是相对固定的，\r\n进程在运行期间既不能创建也不能删除它。\r\n可消耗性资源： 每一类可消耗性资源的单元数口在进程运行期间是可以不断\r\n变化的， 有时它可以有许多， 有时可能为0。 进程在运行过程中， 可以不断创造\r\n可消耗性资源的单元， 将它们放入该资源类的缓冲区中， 以增加该资源类的单元\r\n数目。 进程在运行过程中， 可以请求若干个可消耗性资源单元， 用于进程自己的\r\n消耗， 不再将它们返回给该资源类中。', '0');
INSERT INTO `question_answer` VALUES ('73', '竞争不可抢占资源所引起的死锁是什么?', '例如， 系统中有两个进程P1和P2， 它们都准备写两个文件F1和F2， 而这两者\r\n都属于可重用和不可抢A性资源。 进程P1先打开F1， 然后再打开文件F2 : 进程P2先\r\n打开文件F2， 后打开F1，两个进程PI和P2在并发执行时， 如果P1先打开H和F2， 然后P2才去打开F1（或\r\nF2） ， 由于文件F1（F2） 已被P1打开， 故P2会被阻塞。 当P1写完文件F1（或F2）\r\n而关闭F1（F2） 时， P2会由阻塞状态转为就绪状态， 被调度执行后重新打开文件\r\nF1（或F2） 。 在这种情况下， P1和P2都能正常运行下去。 若P2先打开H和F2， 然\r\n后P1才去打开H（或F2） ， P1和P2同样也可以正常运行下去。\r\n但如果在P1打开H的同时， P2去打开F2， 每个进程都占有一个打开的文件，\r\n此时就可能出现问题。 因为当P1试图去打开F2， 而P2试图去打开F1时， 这两个进\r\n程都会因文件已被打开而阻塞， 它们希望对方关闭自己所需要的文件， 但谁也无\r\n法运行， 因此这两个进程将会无限期地等待下去， 而形成死锁。', '0');
INSERT INTO `question_answer` VALUES ('74', '何谓死锁?产生死锁的原因和必要条件是什么?', '（1） 死锁是指多个进程因竞争资源而造成的一种僵局， 若无外力作\r\n用， 这些进程都将永远不能再向前推进：\r\n(2) 产生死锁的原因有二， 一是竞争资源， 二是进程推进顺序非法；\r\n(3) 必要条件是： 互斥条件， 请求和保持条件， 不剥夺条件和环路等待\r\n条件。', '0');
INSERT INTO `question_answer` VALUES ('75', '在解决死锁问题的几个方法中,哪种方法最易于实现?哪种方法使资源利用率最高?', '解决/处理死锁的方法有预防死锁、 避免死锁、 检测和解除死锁， 其中\r\n预防死锁方法最容易实现， 但由于所施加的限制条件过于严格， 会导致系统资源\r\n利用率和系统吞吐麗降低； 而检测和解除死锁方法可是系统获得较好的资源利用\r\n率和系统吞吐量。', '0');
INSERT INTO `question_answer` VALUES ('76', '可通过哪些途径预防死锁?', '（1） 摒弃： “请求和保持” 条件： 系统规定所有进程开始运行之前，\r\n都必须一次性地申请其在整个运行过程所需的全部资源， 但在分配资源时， 只要\r\n有一种资源不能满足某进程的要求， 即使其它所需的各资源都空闲， 也不分配给\r\n该进程， 而让该进程等待；\r\n(2) 摒弃“不剥夺” 条件： 系统规定， 进程是逐个地提出对资源的要求\r\n的。 当一个已经保持了某些资源的进程， 再提出新的资源请求而不能立即得到满\r\n足时， 必须释放它已经保持了的所有资源， 待以后需要时再重新申请；\r\n(3) 摒弃“环路等待” 条件： 系统将所有资源按类型进行线性排序， 并\r\n赋予不同的序号， 且所有进程对资源的请求必须严格按序号递增的次序提出， 这\r\n样， 在所形成的资源分配罔中， 不可能再出现环路， 因而摒弃了\"环路等待\"条件。', '0');
INSERT INTO `question_answer` VALUES ('77', '为什么要配置层次式存储器?', 'a． 设置多个存储器吋以使存储器两端的硬件能并行工作。\r\nb. 采用多级存储系统， 特别是Cache技术， 这是一种减轻存储器带宽对系\r\n统性能影响的最佳结构方案。\r\nc. 在微处理机内部设置各种缓冲存储器， 以减轻对存储器存取的压力。 增\r\n加CPU中寄存器的数量， 也可大大缓解对存储器的压力。', '0');
INSERT INTO `question_answer` VALUES ('78', '可采用哪几种方式将程序装入内存?', '将程序装入内存可采用的方式有： 绝对装入方式、 重定位装入方式、 动态运\r\n行时装入方式； 绝对装入方式适用于单道程序环境中， 重定位装入方式和动态运\r\n行时装入方式适用于多道程序环境中。', '0');
INSERT INTO `question_answer` VALUES ('79', '何谓静态链接?静态链接时需要解决两个什么问题?', ' 静态链接是指在程序运行之前， 先将各自目标模块及它们所需的库函数，\r\n链接成一个完整的装入模块， 以后不再拆开的链接方式。\r\n将几个目标链接装配成一个装入模块时， 需解决以下两个问题：\r\n将相对地址进行修改。 即将除第一个模块外的相对地址修改成装入模块中的\r\n相应的相对地址。\r\n变换外部调用符号。 即将每个模块中所用的外部调用符号， 都变换为相对地\r\n址。', '0');
INSERT INTO `question_answer` VALUES ('80', '何谓装入时动态链接?装入时动态链接方式有何优点?', ' 装入时动态链接是指将用户源程序编泽后所得到的一组目标模块， 在装\r\n入内存时， 采用边装入边链接的一种链接方式， 即在装入一个目标模块时， 若发\r\n生一个外部模块调用事件， 将引起装入程序去找相应的外部目标模块， 把它装入\r\n内存中， 并修改0标模块中的相对地址。装入时动态链接方式有以下优点：\r\n（1） 便于修改和更新； （2） 便于实现对目标模块的共享。', '0');
INSERT INTO `question_answer` VALUES ('81', '何谓运行时动态链接?运行时动态链接方式有何优点?', ' 运行时动态链接是将对某些模块的链接推迟到程序执行时才进行链接，\r\n也就是， 在执行过程中， 当发现一个被调用模块尚未装入内存时， 立即由OS去找\r\n到该模块并将之装入内存， 把它链接到调用者模块上。\r\n优点： 凡是在执行过程中未被JT1过的目标模块， 都不会被调入内存和被链\r\n接到装入模块上， 这样不仅能加快程序的装入过程， 而且可节省大量的内存空间。', '0');
INSERT INTO `question_answer` VALUES ('82', '在动态分区分配方式中,应如何将各空闲分区链接成空闲分区链?', '应在每个分区的起始地址部分， 设置一些用于控制分区分配的信息， 以及用\r\n于链接各分区的前向指针； 在分区尾部则设置一后向指针， 通过前， 后向指针将\r\n所有的分区链接成一个双向链.', '0');
INSERT INTO `question_answer` VALUES ('83', '为什么要引入动态重定位?如何实现?', 'a. 程序在运行过程中经常要在内存中移动位置， 为了保证这些被移动了\r\n的程序还能正常执行， 必须对程序和数据的地址加以修改， 即重定位。 引入\r\n重定位的目的就是为了满足程序的这种需要。\r\nb. 要在不影响指令执行速度的同时实现地址变换， 必须有硬件地址变换机\r\n构的支持， 即须在系统中增设一个重定位寄存器， 用它来存放程序在内存中\r\n的起始地址。 程序在执行时， 真正访问的内存地址是相对地址与重定位寄存\r\n器中的地址相加而形成的。', '0');
INSERT INTO `question_answer` VALUES ('84', '什么是基于顺序搜索的动态分区分配算法?它可分为哪几种?', '为了实现动态分区式分配， 将系统中的空闲分区组织成空闲分区表或空\r\n闲分区链。 所谓顺序搜索， 是指按表或链的组织顺序， 检索表或链上记录的空闲\r\n分区， 去寻找一个最符合算法的、 大小能满足要求的分区。 分区存储管理中常采\r\n用的分配策略有： 首次适应算法、 循环首次适应算法、 最佳适应算法、 最坏适应\r\n算法。', '0');
INSERT INTO `question_answer` VALUES ('85', '在采用首次适应算法回收内存时,可能出现哪几种情况?', 'a. 回收区与插入点的前一个分区相邻接， 此时可将回收区与插入点\r\n的前一分区合并， 不再为冋收分区分配新表项， 而只修改前邻接分区的大小；\r\nb. 回收分区与插入点的后一分区相邻接， 此时合并两区， 然后用回收区\r\n的首址作为新空闲区的首址， 大小为两者之和；\r\nc. 回收区同时与插入点的前后两个分区邻接， 此时将三个分区合并， 使\r\n用前邻接分区的首址， 大小为三区之和， 取消后邻接分区的表项；\r\nd. 回收区没有邻接空闲分区， 则应为回收区单独建立一个新表项， 填写\r\n回收区的首址和大小， 并根据其首址， 插入到空闲链中的适当位置。', '0');
INSERT INTO `question_answer` VALUES ('86', '什么是基于索引搜索的动态分区分配算法?它可分为哪几种?', ' P13L快速适应算法、 伙伴系统、 哈希算法', '0');
INSERT INTO `question_answer` VALUES ('87', '分区存储管理中常用哪些分配策略?', '分区存储管理中常釆用的分配策略有： 首次适应算法、 循环首次适应算法、\r\n最佳适应算法、 最坏适应算法。', '0');
INSERT INTO `question_answer` VALUES ('88', '为什么要引入对换?对换可分为哪几种类型?', '在多道环境下， 一方面， 在内存中的某些进程由于某事件尚未发生而被\r\n阻塞， 但它却占用了大量的内存空间， 甚至有时可能出现在内存中所有进程都被\r\n阻塞而迫使CPU停止下来等待的情况； 另一方面， 却又有着许多作业在外存上等\r\n待， 因无内存而不能进入内存运行的情况。 显然这对系统资源是一种严重的浪费，\r\n且使系统吞吐量下降。为了解决这一问题， 在操作系统中引入了对换（也称交换）\r\n技术。 可以将整个进程换入、 换出， 也可以将进程的一部分（页、 段） 换入、 换\r\n出。 前者主要用于缓解目前系统中内存的不足， 后者主要用于实现虚拟存储。', '0');
INSERT INTO `question_answer` VALUES ('89', '对文件区管理的目标和对对换空间管理的目标有何不同?', '对文件区管理的主要目标是提高文件存储空间的利用率， 然后才提高对\r\n文件的访问速度， 因此， 对文件区空间的管理采取离散分配方式。\r\n对对换空间管理的主要目标是提高进程换入和换出的速度， 然后才是提高文\r\n件存储空间的利用率， 因此， 对对换区空间的管理采取连续分配方式， 较少的考\r\n虑外存中的碎片问题。', '0');
INSERT INTO `question_answer` VALUES ('90', '为实现对换,系统应具备哪几方面的功能?', '系统应具备三方面功能： 对换空间管理， 进程换出， 进程换入。', '0');
INSERT INTO `question_answer` VALUES ('91', '在以进程为单位进行对换时,每次是否都将整个进程换出?为什么?', ' 在以进程为单位进行对换时， 并非每次将整个进程换出。 这是因为：\r\na. 从结构上讲， 进程是由程序段、 数据段和进程控制块组成的， 其中进\r\n程控制块总有部分或全部常驻内存， 不被换出。\r\nb. 程序段和数据段可能正被若干进程共享， 此时它们也不能被换出。', '0');
INSERT INTO `question_answer` VALUES ('92', '基于离散分配时所用的基本单位不同,可将离散分配分为哪几种?', '分页存储管理方式、 分段存储管理方式和段页式存储管理方式。', '0');
INSERT INTO `question_answer` VALUES ('93', '什么是页面?什么是物理块?页面的大小应如何确定?', '\r\n表就有多少行。每一行记录进程的一页和它存放的物理块的页号、 块号对应关系。\r\n页面： 分页存储管理将进程的逻辑地址空间分成若干个页， 并为各页加\r\n以编号。 物理块： 把内存的物理地址空间分成芯干个块， 并为各块加以编号。 页\r\n面大小应选择适中， 且页面火小应该是2的幂， 通常为1KB~8KB。', '0');
INSERT INTO `question_answer` VALUES ('94', '什么是页表?页表的作用是什么?', '页表是分页式存储管理使用的数据结构。 一个进程分为多少页， 它的页\r\n表就有多少行。每一行记录进程的一页和它存放的物理块的页号、 块号对应关系。\r\n页表用于进行地址变换。', '0');
INSERT INTO `question_answer` VALUES ('95', '为实现分页存储管理,需要哪些硬件支持?', '需要有页表机制、 地址变换机构的硬件支持。', '0');
INSERT INTO `question_answer` VALUES ('96', '在分页系统中是如何实现地址变换的?', '利用地址变换机构实现从逻辑地址到物理地址的转变换， 通过页表来实\r\n现从页号到物理块号的变换， 将逻辑地址中的页号转换为内存中的物理块号。', '0');
INSERT INTO `question_answer` VALUES ('97', '较详细的说明引入分段存储管理方式是为了满足用户哪几个方面的需\r\n求？', '（1） 方便编程。 用户通常把自己的作业按照逻辑关系划分为若干段，\r\n每段都从0编址， 并有自已名字和长度。 因此， 希望要访问的逻辑地址是由段名\r\n和段内偏移量决定。\r\n（2） 信息共享。 在实现对程序和数据的共享时， 是以信息逻辑单位为基础。\r\n分页系统中的页是存放信息的物理单位， 无完整意义， 不便于共享； 段是信息的\r\n逻辑单位。 为了实现段的共享， 希望存储管理能与用户程序分段的组织方式相适\r\n应。\r\n（3） 信息保护。 对信息的逻辑单位进行保护， 分段能更有效方便地实现信\r\n息保护功能。\r\n（4） 动态增长。 在实际应用中， 有些段特別是数据段， 在使用过程中会不\r\n断增长， 事先又无法确切知道增长多少。 分段存储管理方式能较好解决这个\r\n问题\r\n（5） 动态链接。 运行时先将主程序对应的目标程序装入内存并启动运行，\r\n运行过程中又需要调用某段时， 才将该段调入内存链接。 所以动态链接也要\r\n求以段作为管理单位 ', '0');
INSERT INTO `question_answer` VALUES ('98', '在具有快表的段页式存储管理方式中,如何实现地址变换?', '在CPU给出有效地址后， 由地址变换机构自动将页号P送入高速缓冲寄存\r\n器， 并将此页号与高速缓存中的所有页号比较， 若找到匹配页号， 表示要访问的\r\n页表项在快表中。 可直接从快表读出该页对应物理块号， 送到物理地址寄存器中。\r\n如快表中没有对应页表项， 则再访问内存页表， 找到后， 把从页表项中读出物理\r\n块号送地址寄存器； 同时修改快表， 将此页表项存入快表。 但若寄存器已满， 则\r\nOS必须找到合适的页表项换出。', '0');
INSERT INTO `question_answer` VALUES ('99', '为什么说分段系统比分页系统更易于实现信息的共享和保护?', ' a. 对于分方系统， 每个页面是分散存储的， 为了实现信息共享和保\r\n护， 则页面之间需要一一对应起来， 为此需要建立大量的页表项；\r\nb． 而对于分段系统， 每个段都从0开始编址， 并采用_段连续的地址空间，\r\n这样在实现共享和保护时， 只需为所要共享和保护的程序设置一个段表项， 将其\r\n中的基址与内存地址一一对应起来即可。', '0');
INSERT INTO `question_answer` VALUES ('100', '分页和分段存储管理有何区别?', ' a. 分页和分段都采HI离散分配的方式， 且都要通过地址映射机构來\r\n实现地址变换， 这是它们的共同点；\r\nb. 对于它们的不同点有二， 第一， 从功能上看， 页是信息的物理单位，\r\n分页是为实现离散分配方式， 以消减内存的外零头， 提高内存的利用率， 即满足\r\n系统管理的需要， 而不是用户的需要； 而段是信息的逻辑单位， 它含有一组其意\r\n义相对完整的信息。 目的是为了能更好地满足用户的需要； 第二页的大小固定且\r\n由系统确定， 而段的长度却不同定， 决定于用户所编写的程序； 第三分页的作业\r\n地址空间是一维的。 而分段的作业地址空间是二维的。', '0');
INSERT INTO `question_answer` VALUES ('101', '连续分配方式和离散分配方式有何不同?', '连续分配是指为一个用户程序分配一个连续的地址空间， 包括单一\r\n连续分配方式和分区式分配方式， 前者将内存分为系统区和用户区， 系统区供操\r\n作系统使用， 用户区供用户使用， 是最简单的一种存储方式， 但只能用于单用户\r\n单任务的操作系统中；离散分配方式基于将一个进程直接分散地分配到许多不相邻的分区中\r\n的思想， 分为分页式存储管理， 分段存储管理和段页式存储管理。', '0');
INSERT INTO `question_answer` VALUES ('102', '常规存储器管理方式具有哪两大特征? 它对系统性能有何影响?', ' 一次性： 进程必须全部装入内存， 对空间浪费非常大； 驻留性： 在程序\r\n运行过程中， 进程全部驻留在内存， 暂时不用的数据无法释放。', '0');
INSERT INTO `question_answer` VALUES ('103', '什么是程序运行时的时间局限性和空间局限性?', '（1） 时间局限性： 如果程序中的某条指令一旦执行， 则不久的将来该\r\n指令可能再次被执行； 如果某个存储单元被访问， 则不久的将来该存储单元可能\r\n再次被访问。 产生时间局限性的典型原因是在程序中存在着大量的循环操作。\r\n（2） 空间局限性： 一旦程序访问了某个存储单元， 则在不久的将来， 其附\r\n近的存储单元也最有可能被访问， 即程序在一段时间内所访问的地址， 可能集中\r\n在一定的范围内。 产生空间局限性的典型原因是程序是顺序执行的。', '0');
INSERT INTO `question_answer` VALUES ('104', '虚拟存储器有哪些特征?其中最本质的特征是什么?', '虚拟存储器有多次性、 对换性、 虚拟性三大特征。 最本质的特征是虚拟\r\n性。', '0');
INSERT INTO `question_answer` VALUES ('105', '实现虚拟存储器需要哪些硬件支持?', 'a. 请求分页（段） 的页（段） 表机制； b. 缺页（段） 中断机构； c. 地址变\r\n换机构。', '0');
INSERT INTO `question_answer` VALUES ('106', '实现虚拟存储器需要哪几个关键技术?', '（1） 在分页请求系统中是在分页的基础上， 增加了请求调页功能和页\r\n面置换功能所形成的页式虚拟存储系统。允许只装入少数页面的程序（及数据），\r\n便启动运行。 （2） 在请求分段系统中是在分段系统的骓础上， 增加了请求调段\r\n及分段置换功能后形成的段式虚拟存储系统。 允许只装入少数段（而非所有段）\r\n的用户程序和数据， 即可启动运行。', '0');
INSERT INTO `question_answer` VALUES ('107', '在请求分页系统中,页表应包括哪些数据项?每项的作用是什么?', '页表应包括： 页号、 物理块号、 状态位P、 访问字段A、 修改位M和外存\r\n地址。 其中状态位P指示该页是否调入内存， 供程序访问时参考 ： 访问字段A用于\r\n记录本页在_段时间内被访问的次数， 或最近己有多长时间未被访问， 提供给H\r\n换算法选择换出页面时参考； 修改位M表示该页在调入内存后是否被修改过； 外\r\n存地址用于指出该页在外存上的地址， 通常是物理块号， 供调入该页时使用。', '0');
INSERT INTO `question_answer` VALUES ('108', '试比较缺页中断机构与一般的中断,它们之间有何明显的区别?', 'a. 一般中断只需要保护现场然后就直接跳到需及时处理的地方。\r\nb. 缺页中断除了保护现场之外， 还要判断内存中是否有足够的空间存储所需\r\n的页或段， 然后再把所需页调进来再使用。', '0');
INSERT INTO `question_answer` VALUES ('109', '试说明请求分页系统中的地址变换过程是什么?', '1) 取逻辑地址分解为页号P和页内偏移w；\r\n2) 根据页号查找页表， 获得该页的描述信息；\r\n3) 若该页中断位为1， 产生缺页中断；\r\n4) 更新该页的描述信息；\r\n5) 根据页块号和页内偏移w， 计算物理地址^', '0');
INSERT INTO `question_answer` VALUES ('110', '何谓固定分配局部置换和可变分配全局置换的内存分配策略?', '(1) 固定分配局部置换\r\n固定分配是指， 为每个进程分配一组固定数目 的物理块， 在进程运行期\r\n间不再改变。\r\n局部置换是指， 如果进程在运行中发现缺页， 则只能从分配给该进程的n\r\n个页面中， 选出一页换出， 然后再调入一页。\r\n(2) 可变分配全局置换\r\n可变分配是指， 先为每个进程分配一定数目 的物理块， 在进程运行期间，\r\n可根据情况做适当地改变。\r\n全局置换是指， 如果进程在运行中发现缺页， 则将OS所保留的空闲物理\r\n块或者以所有进程的全部物理块为标的， 选择一块换出， 然后将所缺之页调\r\n入。', '0');
INSERT INTO `question_answer` VALUES ('111', '在请求分页系统中,应从何处将所需页面调入内存?', ' 请求分页系统中的缺页从何处调入内存分三种情况：\r\n(1) 系统拥有足够对换区空间时， 可以全部从对换区调入所需页面， 提\r\n高调页速度。 在进程运行前将与该进程有关的文件从文件区拷贝到对换区。\r\n(2) 系统缺少足够对换区空间时， 不被修改的文件直接从文件IK调入；\r\n当换出这些页面时， 未被修改的不必换出， 再调入时， 仍从文件区直接调入 9 对\r\n于可能修改的， 在换出时便调到对换区， 以后需要时再从对换区调入。\r\n(3) UNIX方式。 未运行页面从文件E调入。 曾经运行过但被换出页面， 下\r\n次从对换区： 调入。 UNIX系统允许页面共享， 某进程请求的页面有可能已调入内\r\n存， 直接使用不再调入。', '0');
INSERT INTO `question_answer` VALUES ('112', '试说明在请求分页系统中页面的调入过程?', '每当程序所要访问的页面未在内存时（存在位为“0” ） ， 便向CPU发出\r\n一缺页中断， 中断处理程序首先保留CPU环境， 分析中断原因后， 转入缺页中\r\n断处理程序。 该程序通过查找页表， 得到该页在外存的物理块后， 如果此时\r\n内存能容纳新页， 则启动磁盘I/0， 将所缺之页调入内存， 然后修改页表。 如\r\n果内存巳满， 则须先按照某种置换算法， 从内存中选出一页准备换出； 如果\r\n该页未被修改过（修改位为“0” ） ， 可不必将该页写回磁盘； 但如果此页已\r\n被修改（修改位为“1” ） ， 则必须将它写回磁盘， 然后再把所缺的页调入内\r\n存， 并修改页表中的相应表项， 置其存在位为“1” ， 并将此页表项写入快表\r\n中。 在缺页调入内存后， 利用修改后的页表， 去形成所要访问数据的物理地\r\n址， 再去访问内存数据。 整个页面的调入过程对用户是透明的。', '0');
INSERT INTO `question_answer` VALUES ('113', '在请求分页系统中,常采用哪几种页面置换算法?', '采用的页面置换算法有： 最佳置换算法和先进先出置换算法， 最近\r\n最久未使用（LRU) 置换算法， Clock置换算法， 最少使用置换算法， 页面缓冲\r\n算法等。', '0');
INSERT INTO `question_answer` VALUES ('114', '实现LRU算法所需的硬件支持是什么?', ' 需要寄存器和栈等硬件支持。 寄存器用于记录某进程在内存中各页的使\r\n用情况， 栈用于保存当前使用的各个页面的页面号。', '0');
INSERT INTO `question_answer` VALUES ('115', '试说明改进型Clock 置换算法的基本原理是什么?', '因为修改过的页面在换出时付出的开销比未被修改过的页面大， 在改进\r\n型Clock算法中， 既考虑页面的使用情况， 还要增加置换代价的因素； 在选择页\r\n面作为淘汰页面时， 把同时满足未使用过和未被修改作为首选淘汰页面。', '0');
INSERT INTO `question_answer` VALUES ('116', '影响页面换进换出效率的若干因素是什么?', '（1） 页面置换算法： 影响页面换进换出效率最重要的因素， 直接影响进\r\n程在运行过程中的缺页率， 影响页面换进换出的开销。\r\n（2） 写回磁盘的频率： 如果是采取每个页面换出时， 就将它写回磁盘的\r\n策略， 这意味着每换出一个页面， 便需要启动一次磁盘。 但如果在系统中建\r\n立了一个已修改换出页面链表， 对每一个要被换出的页面（已修改） ， 系统\r\n可暂不把它们写回磁盘， 而是将它们挂在已修改换出页面链表上， 仅当被换\r\n出页面数目 达到一定值时， 再将它们一起写回到磁盘上， 这样就显著地减少\r\n了磁盘I/O的操作次数。 或者说， 减少已修改页面换出的开销。\r\n（3） 读入内存的频率： 在设置了已修改换出页面链表后， 在该链表上就\r\n暂时有一批装有数据的页面， 如果需要再次访问这些页面时， 就不需从外存\r\n上调入， 而直接从已修改换出页面链表中获取， 这样也可以减少将页面从磁\r\n盘读入内存的频率， 减少页面换进的开销。 或者说只需花费很小的开销， 便\r\n可使这些页面， 又回到该进程的驻留集中。', '0');
INSERT INTO `question_answer` VALUES ('117', '页面缓冲算法的主要特点是什么?它是如何降低页面换进,换出的频率的?', '①显著地降低了页面换进、 换出的频率， 使磁盘I/O的操作次数大为减少，\r\n因而减少了页面换进、 换出的开销；\r\n②由于换入换出的开销大幅度减小， 才能使其釆用一种较简单的置换策\r\n略， 如先进先出（FIFO） 算法， 它不需要特殊硬件的支持， 实现起来非常简\r\n单。\r\n在该系统中， 内存分配策略上釆用了可变分配和局部置换方式。 为了能\r\n显著地降低了页面换进、 换出的频率， 在内存中设置了如下两个链表：\r\n⑴空闲页面链表： 是一个空闲物理块链表， 用于分配给频繁发生缺页的\r\n进程， 以降低该进程的缺页率。 当有一个未被修改的页要换出时， 实际上并\r\n不将它换出到外存， 而是把它们所在的物理块， 挂在空闲链表的末尾。\r\n⑵修改页面链表： 由已修改的页面所形成的链表， 设置该链表的目 的，\r\n是为了减少已修改页面换出的次数。 降低将已修该页面写回磁盘的频率， 以\r\n及降低将磁盘内容读入内存的频率。', '0');
INSERT INTO `question_answer` VALUES ('118', '在请求分页系统中,产生“抖动”的原因是什么?', 'a. 抖动（Thrashing） 就是指当内存中已无空闲空间而又发生缺页中断吋，\r\n需要从内存中调出一页程序或数据送磁盘的对换区中， 如果算法不适当， 刚被换\r\n出的页很快被访问， 需重新调入， 因此需再选一页调出， 而此时被换出的页很快\r\n又要被访问， 因而又需将它调入， 如此频繁更换页面， 使得系统把大部分时间用\r\n在了页面的调进换出上， 而几乎不能完成任何有效的工作， 我们称这种现象为“抖\r\n动” 。\r\nb. 产生抖动的原因是由于CPU的利用率和多道程序度的对立统一矛盾关\r\n系引起的， 为了提高CPU利用率， 可提高多道程序度， 但单纯提高多道程序度又\r\n会造成缺页率的急剧上升， 导致CPU的利用率下降， 而系统的调度程序又会为了\r\n提高CPU利用率而继续提高多道程序度， 形成恶性循环， 我们称这时的进程是处\r\n于“抖动” 状态。', '0');
INSERT INTO `question_answer` VALUES ('119', '何谓工作集?它是基于什么原理确定的?', '工作集（或驻留集） 是指在某段时间间隔内， 进程要访问的页面集合。\r\n经常被使用的页面需要在工作集中， 而长期不被使用的页面要从工作集中被丢弃\r\ns 为了防止系统出现抖动现象， 需要选择合适的工作集大小。 工作集模型的原理\r\n是： 让操作系统跟踪每个进程的工作集， 并为进程分配大于其工作集的物理块。\r\n如果还有空闲物理块， 则可以再调一个进程到内存以增加多道程序数。 如果所有\r\n工作集之和增加以至于超过了可用物理块的总数， 那么操作系统会暂停一个进程，\r\n将其页面调出并且将其物理块分配给其他进程， 防止出现抖动现象。 正确选择工\r\n作集的大小， 对存储器的利用率和系统吞吐量的提高， 都将产生重要影响。', '0');
INSERT INTO `question_answer` VALUES ('120', '当前可以利用哪几种方法来防止“抖动”?', '⑴采取局部置换策略； ⑵把工作集算法融入到处理机调度中；\r\n⑶ 利用“L=S” 准则调节缺页率； ⑷选择暂停的进程', '0');
INSERT INTO `question_answer` VALUES ('121', '试说明如何利用“L=S”准则来调节缺页率,以避免“抖动”的发生?', '于1980年Denning提出了“L=S” 的准则， 来调节多道程序度， 其中L是缺\r\n页之间的平均时间， S是平均缺页服务时间， 即用于置换一个页面所需的时间。\r\n利用“L=S” 准则， 对于调节缺页率是十分有效的。', '0');
INSERT INTO `question_answer` VALUES ('122', '为了实现请求分段式存储管理,应在系统中增加配置哪些硬件机构?', ' 请求段表机制、 缺段中断机制和地址变换机构。', '0');
INSERT INTO `question_answer` VALUES ('123', '在请求段表机制中,应设置哪些段表项?', '段名 段长 段的基址 方式 访问字段A 修改位M 存在位P 增补位 外存始址。存取方式， 访问字段A， 修改位M， 存在位P， 增补位， 外存始址。', '0');
INSERT INTO `question_answer` VALUES ('124', '请求分段系统中的缺页中断处理过程是什么?', '(1) 根据当前执行指令中的逻辑地址查页表， 判断该页是否在主存储器中；\r\n(2) 该页标志为“0” 形成缺页中断， 中断装置通过交换PSW让操作系统\r\n的中断处理程序占用处理器；\r\n(3) 操作系统处理缺页中断处理的办法是査主存分配表找一个空闲的主\r\n存块， 查页表找出该页在磁盘上位置， 启动磁盘读出该页信息；\r\n(4) 把从磁盘上读出的信息装入找到的主存块中；\r\n(5) 当页面住处被装入主存后， 应修改页表中对应的表口， 填上该页所\r\n占用的主存块把标志置为“丨 ” ， 表示该页已在主存储器中；\r\n(6) 由于产生缺页中断时的那条指令并没执行完， 所以在把页面装入之\r\n后应重新执行被中断指令。', '0');
INSERT INTO `question_answer` VALUES ('125', '如何实现共享分段的分配和回收?', '①共享段的分配： 在为共享段分配内 存时， 对第一个请求使用 该共享\r\n段的进程， 由 系统为该共享段分配一物理区， 当又有其它进程需要调用 该\r\n共享段时， 无须再为该段分配内 存。\r\n②共享段的回收： 当共享此段的某进程不再需要该段时， 若无其他进\r\n程使用 该段， 则由系统回收该共享段的物理内 存， 否则只 是取消调用 者进\r\n程在共享段表中的有关记录。', '0');
INSERT INTO `question_answer` VALUES ('126', 'I/O系统的基本功能是什么?', ' a. 隐藏物理设备的细节； b. 与设备的无关性； c. 提高处理机和I/O设备\r\n的利用率； d. 对I/O设备进行控制； e. 确保对设备的正确共享； f. 错误处理', '0');
INSERT INTO `question_answer` VALUES ('127', 'I/O软件的四个层次的基本功能是什么?', ' 中断处理程序： 用于保存被中断进程的CPU环境， 转入相应的中断处理\r\n程序进行处理， 处理完后恢复现场， 并返回到被中断的进程设备驱动程序： 与硬\r\n件直接有关， 用来具体实现系统对设条发出的操作指令， 驱动I/O设备工作。\r\n设备独立性软件： 用于实现用户程序与设备驱动器的统一接口、 设备命令、\r\n设备保护， 以及设备分配与释放等。', '0');
INSERT INTO `question_answer` VALUES ('128', 'I/0系统接口与软件/硬件(RW/HW)接口分别是什么接口?', ' I/0系统接口是I/O系统与上层系统之间的接口， 向上层提供对设备进行\r\n操作的抽象I/O命令， 以方便高层对设备的使软件/硬件（RW/HW） 接口的上面\r\n是中断处理程序何用于不同设备的设备驱动程序， 它的下面是各种设备的控制器。', '0');
INSERT INTO `question_answer` VALUES ('129', '与设备无关性的基本含义是什么?为什么要设置该层?', '为了提高OS的可适应性和可扩展性， 在现代OS中都毫无例外地实现了设\r\n备独立性， 也称设备无关性。 基本含义： 应用程序独立于具体使用的物理设备。\r\n为了实现设备独立性而引入了逻辑设备和物理设备两概念。 在应用程序中， 使用\r\n逻辑设备名称来请求使用某类设备 ： 而系统在实际执行时， 还必须使HI物理设备\r\n名称。 优点： 1. 设备分配时的灵活性； 2. 易于实现I/O重定向（用于I/O操作的设\r\n备可以更换（即重定向） ， 而不必改变应用程序。', '0');
INSERT INTO `question_answer` VALUES ('130', '设备控制器的组成是什么?', ' 设置控制器与处理机的接口； 设备控制器与设备的接口； I/O逻辑。', '0');
INSERT INTO `question_answer` VALUES ('131', '为了实现CPU与设备控制器间的通信,设备控制器应具备哪些功能?', ' 基本功能： 接收和识别命令； 数据交换； 标识和报告设备的状态 ： 地址\r\n识别： 数据缓冲； 差错控制。', '0');
INSERT INTO `question_answer` VALUES ('132', '为了实现CPU与设备控制器之间的通信， 设备控制器应该具备哪些功能？', '基本功能： 接收和识别命令； 数据交换； 标识和报告设备的状态 ： 地址\r\n识别： 数据缓冲； 差错控制。', '0');
INSERT INTO `question_answer` VALUES ('133', '为什么说中断是OS赖以生存的基础?', '中断在操作系统中有着特殊重要的地位， 它是多道程序得以实现的基础，\r\n没有中断， 就不可能实现多道程序， 因为进程之间的切换是通过中断来完成的。\r\n另一方面， 中断也是设备管理的基础， 为了提高处理机的利用率和实现CPU和I/\r\nO设备并执行， 也必需有中断的支持。 中断处理程序是I/O系统中最低的一层， 它\r\n是整个I/O系统中最低的一层。', '0');
INSERT INTO `question_answer` VALUES ('134', '对多中断源的两种处理方式分别用于何种场合?', ' 1） 屏蔽（禁止） 中断： 当处理机正在处理一个中断时， 将屏蔽掉所有\r\n的中断， 直到处理机己处理完本次中断， 再去检査是否有中断产生。 所有中断按\r\n顺序处理， 优点是简单， 但不能用于实时性要求较高的中断请求。\r\n2） 嵌套中断： 在设置了中断优先级的系统中， 当同时有多个不同优先级的\r\n中断请求， CPU优先响应优先级最高的中断请求。 高优先级的中断请求可以抢占\r\n正在运行的低优先级中断的处理机。', '0');
INSERT INTO `question_answer` VALUES ('135', '设备中断处理程序通常需完成哪些工作?', '1、 唤醒被阻塞的驱动进程； 2、 保护被中断进程的CPU环境； 3、 转入相\r\n应的设备处理程序； 4、 中断处理； 5、 恢复被中断进程的现场。', '0');
INSERT INTO `question_answer` VALUES ('136', '中断处理程序对中断进行处理的几个步骤是什么?', ' 1、 测定是否有未响应的中断信号； 2、 保护被中断进程的CPU环境； 3、\r\n转入相应的设备处理程序； 4、 中断处理； 5、 恢SCPU的现场并退出中断', '0');
INSERT INTO `question_answer` VALUES ('137', '设备驱动程序具有哪些特点?', '(1) 将接收到的抽象要求转为具体要求；\r\n(2) 检查用户I/O请求合法性， 了解I/O设备状态， 传递有关参数， 设置\r\n设备工作方式；\r\n(3) 发出I/O命令， 启动分配到的I/O设备， 完成指定I/O操作；\r\n(4) 及时响应由控制器或通道发来的中断请求， 根据中断类型调HI相应\r\n中断处理程序处理：\r\n(5) 对于有通道的计算机， 驱动程序还应该根据用户I/O请求自动构成通\r\n道程序。', '0');
INSERT INTO `question_answer` VALUES ('138', '设备驱动程序通常要完成哪些工作?', '（1） 将接收到的抽象要求转为具体要求； （2） 检查用户I/O请求合法\r\n性， 了解I/O设备状态， 传递有关参数， 设置设备工作方式； （3） 发出I/O命令，\r\n启动分配到的I/O设备， 完成指定I/O操作； （4） 及时响应由控制器或通道发来\r\n的中断请求， 根据中断类型调用相应中断处理程序处理； （5） 对于有通道的计\r\n算机， 驱动程序还应该根据用户I/O请求自动构成通道程序。', '0');
INSERT INTO `question_answer` VALUES ('139', '设备驱动程序的处理过程可分为哪几步?', ' 1） 将抽象要求转换为具体要求； 2） 对服务请求进行校验； 3） 检查设\r\n备的状态； 4） 传送必要的参数。', '0');
INSERT INTO `question_answer` VALUES ('140', '推动I/0控制发展的主要因素是什么?', '促使I/O控制不断发展的几个主要因素如下：\r\na. 尽量减少CPU对I/O控制的干预， 把CPU从繁杂的I/O控制中解脱出来， 以\r\n便更多地去完成数据处理任务。\r\nb. 缓和CPU的高速性和设备的低速性之间速度不匹配的矛盾， 以提高CPU的\r\n利用率和系统的吞吐量 。\r\nc. 提高CPU和I/O设备操作的并行程度， 使CPU和I/O设各都处于忙碌状态，\r\n从而提高整个系统的资源利用率和系统吞吐量。', '0');
INSERT INTO `question_answer` VALUES ('141', '有哪几种I/O控制方式?', 'I/O控制方式： 程序I/O方式、 中断驱动I/O控制方式、 DMAI/0控制方式、 I/\r\nO通道控制方式。 ', '0');
INSERT INTO `question_answer` VALUES ('142', 'DMA的工作流程是什么?', '以从磁盘读入数据为例， 说明DMA的工作流程。 当CPU要从磁盘读入数\r\n据块时， 先向 磁盘控制器发送一条读命令。 该命令被送到命令寄存器CR中。 同\r\n时还发送本次要读入数据的内存起始目标地址， 送入内存地址寄存器MAR；\r\n本次要读数据的字节数送入数据计数器DC， 将磁盘中的源地址直接送DMA控\r\n制器的I/O控制逻辑上。然后启动DMA控制器传送数据， 以后CPU便处理其它任务。\r\n整个数据传送过程由DMA控制器控制。 ', '0');
INSERT INTO `question_answer` VALUES ('143', '为何要引入与设备的无关性?如何实现设备的独立性?', ' 引入设备独立性， 可使应用程序独立于具体的物理设备， 是设备分配具\r\n有灵活性。 另外容易实现I/O重定向。 为了实现设备独立性， 必须在设备驱动程\r\n序之上设置一层设备独立性软件， 用来执行所有I/O设备的公用操作， 并向用户\r\n层软件提供统一接口。 关键是系统中必须设H—张逻辑设备表LUT用来进行逻辑设\r\n谷到物理设备的映射， 其中每个表口中包含了逻辑设备名、 物理设备名和设备驱\r\n动程序入口地址三项； 当应用程序用逻辑设备名请求分配I/O设备时， 系统必须\r\n为它分配相应的物理设谷， 并在LUT中建立一个表目， 以后进程利用该逻辑设备\r\n名请求I/O操作时， 便可从LUT中得到物理设各名和驱动程序入口地址。', '0');
INSERT INTO `question_answer` VALUES ('144', '与设备的无关的软件中,包括了哪些公有操作的软件?', ' 1、 设备驱动程序的统一接口； 2、 缓冲管理； 3、 差错控制； 4、 对独立\r\n设备的分配与回收； 5、 独立于设备的逻辑数据块。', '0');
INSERT INTO `question_answer` VALUES ('145', '在考虑到设备的独立性时,应如何分配独占设备?', '(1) 进程以逻辑设备名提出I/O请求。\r\n(2) 根据逻辑设备表相应表项获得I/O请求的逻辑设备对应类型的物理\r\n设备在系统设备表中的指针。3) 从指针所指位置起顺序检索系统设备表， 直到找到一个属于对应I/O\r\n请求所用类型、 空闲可JD且基于设备分配安全性算法验证为安全分配的设备的设\r\n备控制表， 将对应设备分配给请求进程； 如果未找到安全可用的空闲设备， 则把\r\n请求进程的进程控制块挂到相应类型设备的等待队列上等待唤醒和分配。\r\n(4) 系统把设备分配给I/O请求进程后， 再到该设备的设备控制表中找出\r\n与其相连接的控制器的控制器控制表， 根椐其状态字段判断该控制器是否忙碌，\r\n芯忙则把请求进程的进程控制块挂到该控制器的等待队列上； 否则将该控制器分\r\n配给进程。(5) 系统把控制器分配给I/O请求进程后， W到该控制器的控制器控制表\r\n中找出与其相连接的通道的通道控制表， 根据其状态字段判断该通道是否忙碌，\r\n若忙则把请求进程的进程控制块挂到该通道的等待队列上； 否则将该通道分配给\r\n进程。', '0');
INSERT INTO `question_answer` VALUES ('146', '何谓设备虚拟?实现设备虚拟时所依赖的关键技术是什么?', '通过虚拟技术可将一台独占设备变换成若干台逻辑设备， 供若干个用户\r\n（进程） 同时使通常把这种经过虚拟技术处理后的设备称为虚拟设备。 其实现所\r\n依赖的关键技术是SPOOLING技术。', '0');
INSERT INTO `question_answer` VALUES ('147', '在实现后台打印时,SPOOLing系统应为请求I/0的进程提供哪些服务?', '1、 由输出进程在输出井中为之申请一空闲盘块区， 并将要打印的数据送入\r\n其中； 2、 输出进程再为用户进程申请一张空白的用户打印表， 并将用户的打印\r\n要求填入其中， 再将该表挂到请求打印队列上。 3、 一旦打印机空闲， 输出进程\r\n便从请求打印队列的队首取出一张请求打印表， 根据表中的要求将要打印的数据\r\n从输出井传送到内存缓冲区， 再由打印机进行打印。', '0');
INSERT INTO `question_answer` VALUES ('148', '假脱机系统向用户提供共享打印机的基本思想是什么?', ' 对每个用户而言， 系统并非即时执行其程序输出数据的真实打印操作，\r\n而只是即时将数据输出到缓冲区， 这时的数据并未真jE被打印， 只是让用户感觉\r\n系统已为他打印： 真正的打印操作， 是在打印机空闲且该打印任务在等待队列中\r\n己排到队首时进行的； 以上过程是对用户屏蔽的， 用户是不可见的。', '0');
INSERT INTO `question_answer` VALUES ('149', '引入缓冲的主要原因是什么?', ' 缓和CPU与I/O设备之间速度不匹配的矛盾： 减少对CPU的中断频率： 放\r\n宽对中断响应时间的限制； 解决数据力度不匹配的问题； 提高CPU和I/O设备之间\r\n的并行性。', '0');
INSERT INTO `question_answer` VALUES ('150', '在单缓冲情况下,为什么系统对一块数据的处理时间为max(C,T)+M?', '在块设备输入时， 假定从磁盘把一块数据输入到缓冲区的时间为T； 操作系\r\n统将缓冲区数据传送给用户区的时间为M : 而CPU对这一块数据进行计算得时间为\r\nC。 在单缓冲情况下， 由于设备的输入操作和CPU的处理操作可以并行， 所以系统\r\n对每一整块数据的处理时间为max（C， T） +M。', '0');
INSERT INTO `question_answer` VALUES ('151', '为什么在双缓冲情况下,系统对一块数据的处理时间为 max(T,C)?', '该方式又称缓冲对换方式， 在设备输入时， 先将数据送入第一缓冲区， 装满\r\n后便转向第二缓冲区。 此时操作系统可以从第一缓冲区移出数据， 并送入用户进\r\n程。 接着由CPU对数据进行计算。 在双缓冲区中， 不仅设备的输入操作和CPU的处\r\n理操作可以并行， 设备的输入操作和数据的传送操作也可以并行， W此耗时大约\r\n为max（C+M， T） 。 考虑到M是内存中数据块的“搬家” 耗时， 非常短暂可以楫略，\r\n因此近似地认为是： max（C， T） 。', '0');
INSERT INTO `question_answer` VALUES ('152', '收容输入工作缓冲区和提取输出工作缓冲区的工作情况是什么?', '①收容输入工作缓冲区的工作情况为： 在输入进程需要输入数据时， 调\r\n用GetBuf（EmptyQueue） 过程， 从RmptyQueue队列的队首摘下一个空缓冲区， 作\r\n为收容输入工作缓冲区Hin。 然后把数据输入其中， 装满后再调用PutBuf（Inpu\r\ntQueue， Hin） 过程， 将该缓冲区挂在输入队列InputQueue的队尾。 ②提取输出\r\n工作缓冲区的工作情况为： 当要输出数据时， 调用GetBuf（OutputQueue） 过程，\r\n从输出队列的队首取得一装满输出数Hi的缓冲K作为提取输出丁。 作缓冲区Sout。\r\n在数据提取完后， 再调用PutBuf（EmptyQueue， Sout） 过程， 将该缓冲区挂到空\r\n缓冲队列EmptyQueue的队尾。', '0');
INSERT INTO `question_answer` VALUES ('153', '何谓安全分配方式和不安全分配方式?', '①安全分配方式是指每当进程发出I/O请求后， 便进入阻塞状态， 直到\r\n其I/O操作完成时才被唤醒。 在采用这种分配策略时， 一旦进程己获得某种设备\r\n资源后便阻塞， 使它不可能再请求任何资源， 而在它运行吋又不保持任何资源。\r\n这种分配方式已经摒弃了造成死锁的“请求和保持” 条件， 分配是安全的。 缺点\r\n是进程进展缓慢， CPU与I/O设备串行工作。\r\n②不安全分配方式是指进程发出I/O请求后仍继续执行， 需要时又可发出第\r\n二个I/O请求、 第三个I/O请求g仅当进程请求的设备已被另一个进程占有时， 进\r\n程才进入阻塞状态。 优点是一个进程可同时操作多个设备， 进程推进迅速。 缺点\r\n是分配不安全， 可能具有“请求和保持” 条件， 可能造成死锁。 因此， 在设备分\r\n配程序中需增加一个功能， 用于对本次的设备分配是否会发生死锁进行安全性计\r\n算， 仅当计算结果表明分配安全的情况下才进行分配。', '0');
INSERT INTO `question_answer` VALUES ('154', '磁盘访问时间由哪几部分组成?', '磁盘访问时间由寻道时间Ts、旋转延迟时间Tr、传输时间Tt三部分组成。\r\n(1) Ts是启动磁臂时间s与磁头移动n条磁道的时间和， 即Ts=m×n+s；\r\n(2) Tr是指定扇区移动到磁头下面所经历的时间。 硬盘15000r/min时Tr\r\n为2ms； 软盘300或600r/min时Tr为50~l00ms；\r\n(3) Tt是指数据从磁盘读出或向磁盘写入经历的时间。 Tt的大小与每次\r\n读/写的字节数b和旋转速度有关： Tt=b/rN。', '0');
INSERT INTO `question_answer` VALUES ('155', '目前常用的磁盘调度算法有哪几种?每种算法优先考虑的问题是什么?', '目前常用的磁盘调度算法有先来先服务、 最短寻道时间优先及扫描等算\r\n法。\r\n(1) 先来先服务算法优先考虑进程请求访问磁盘的先后次序；\r\n(2) 最短寻道时间优先算法优先考虑要求访问的磁道与当前磁头所在磁\r\n道距离是否最近；\r\n(3) 扫描算法考虑欲访问的磁道与当前磁道间的距离， 更优先考虑磁头\r\n当前的移动方向。', '0');
INSERT INTO `question_answer` VALUES ('156', '何谓数据项、记录和文件?', 'a. 数据项是最低级的数据组织形式， 可分为基本数据项和组合数据项。\r\n基本数据项是用于描述一个对象某种属性的字符集， 是数据组织中可以命名的最\r\n小逻辑数据单位， 即原子数据， 又称为数据元素或字段。 组合数据项则由若干个\r\n基本数据项构成。\r\nb. 记录是一组相关数据项的集合， 用于描述一个对象某方面的属性。\r\nc. 文件是指有创建者所定义的、 具有文件名的一组相关信息的集合提。', '0');
INSERT INTO `question_answer` VALUES ('157', '文件系统的模型可分为三层,每一层所包含的基本内容是什么?', '(1) 最低层为对象及其属性说明， 主要包括物理文件相关功能， 包括文\r\n件和目录、 磁盘存储空间等对象。\r\n(2) 中间层是对对象进行操纵和管理的软件集合， 是文件系统的核心部\r\n分， 主要是逻辑文件相关功能。 包括文件存储空间管理、 文件目录管理、 逻辑文\r\n件到物理文件的映射、 文件读写管理及文件共享与保护等诸多功能。\r\n(3) 最高层是文件系统提供给用户的接口， 分为命令接口、 图形化用户\r\n第一层：对象及其属性说明（文件、目录、硬盘或磁带存储空间）；\r\n\r\n第二层：对对象操纵和管理的软件集合（I/O控制层即设备驱动程序、基本文件系统即物理I/O层、基本I/O管理程序或文件组织模块层、逻辑文件系统层）\r\n\r\n第三层：文件系统接口（命令接口/图形化用户接口与程序接口）。', '0');
INSERT INTO `question_answer` VALUES ('158', '何谓数据项、记录和文件？', '①数据项分为基本数据项和组合数据项。基本数据项描述一个对象某种属性的字符集，具有数据名、数据类型及数据值三个特性。组合数据项由若干数据项构成。\r\n\r\n②记录是一组相关数据项的集合，用于描述一个对象某方面的属性。\r\n\r\n③文件是具有文件名的一组相关信息的集合。', '0');
INSERT INTO `question_answer` VALUES ('159', '用户可以对文件施加的主要操作有哪些?', '用户通过文件系统提供的系统调用对文件实施操作。\r\n\r\n（1）基本文件操作：创建、删除、读、写、截断、设置读/写位置等；\r\n\r\n（2）文件打开和关闭操作：第一步通过检索文件目录找到指定文件属性及其在外存上位置；第二步对文件实施读写等相应操作。\r\n\r\n（3）其他文件操作：一是文件属性操作；二是目录操作；三是文件共享与文件系统操作的系统调用实现等。', '0');
INSERT INTO `question_answer` VALUES ('160', '假定一个文件系统的组织方式与MS-DOS相似， 在FAT中可有64K个指针，\r\n磁盘的盘块大小为512B， 试问该文件系统能否指引一个512MB的磁盘？', ' 512MB/512B=1M个盘块， 而每个盘块都应有一个指针来指示， 所以应该\r\n有1M个指针， 因此若有64K个指针则不能指引一个512MB的磁盘。', '0');
INSERT INTO `question_answer` VALUES ('161', '何谓文件的逻辑结构?何谓文件的物理结构?', '文件的逻辑结构是指从用户的观点出发所观察到的文件组织形式， 也就是用\r\n户可以直接处理的数据及其结构， 它独立于物理特性， 而文件的物理结构则是指\r\n文件在外存上的存储组织形式， 与存储介质的存储性能有关。', '0');
INSERT INTO `question_answer` VALUES ('162', '为了快速访问， 又易于更新， 当数据为以下形式时， 应选用何种文件\r\n组织方式？', '（1） 不经常更新， 经常随机访问——顺序结构；（2） 经常更新， 经常按一定顺序访问——索引顺序结构；（3） 经常更新， 经常随机访问——索引结构。\r\n（3） 经常更新， 经常随机访问——索引结构。', '0');
INSERT INTO `question_answer` VALUES ('163', '如何提高对变长记录顺序文件的检索速度?', '为了提高对变长记录顺序文件的检索速度， 可为其建立一张索引表， 以主文\r\n件中每条记录的长度及指向对应记录的指针（即该记录在逻辑地址空间的地址）\r\n作为相应每个表项的内容。 由于索引表本身是一个定长记录的顺序文件， 若将其\r\n按记录键排序， 则可以实现对主文件的方便快速的直接存取。 需要指出的是， 如\r\n果文件较大， 应通过建立分组多级索引以进一步提高检索效率。', '0');
INSERT INTO `question_answer` VALUES ('164', '在UNIX中， 如果一个盘块的大小为1K13， 每个盘块号占4个字节， 即每\r\n块可放256个地址。 请转换下列文件的字节偏移量为物理地址?⑴9999； ⑵18000； ⑶420000', '盘块大小为1KB， 盘块号占4B， 即每个盘块最多可存放256个盘块号， 又根据\r\nUNIX系统中采用的混合索引分配方式可知：\r\n9999/1024=9余783\r\n18000/1024=17余592\r\n420000/1024=410余160', '0');
INSERT INTO `question_answer` VALUES ('165', '可以采取什么方法来实现对变长记录文件进行随机检索?', '为变长记录文件建立一张索引表，索引表中记录每一个变长记录项的地址。因为检索索引表是对定长文件进行检索，就可以实现随机检索。', '0');
INSERT INTO `question_answer` VALUES ('166', '试说明顺序文件的结构及其优点?', '第一种是串结构：各记录之间的顺序与关键字无关。第二种是顺序结构：指文件中的所有记录按关键字（词）排列。可以按关键词长短排序或英文字母顺序排序。', '0');
INSERT INTO `question_answer` VALUES ('167', '索引文件和索引顺序文件的检索方法是什么?', '① 对索引文件进行检索时， 首先根据用户（程序） 提供的关键字， 并利用\r\n某种（折半查找） 算法检索索引表， 从中找到相应的表项； 再利用该表项中给出\r\n的指向记录的指针值， 去访问对应的记录。\r\n② 对索引顺序文件结合了索引和顺序查找， 适合于巨量数据的查找， 它将\r\n数据分组建索引（以减少索引表的长度） ， 首先利用用户（程序） 提供的关键字\r\n以及某种査找方法， 去检索索引表， 找到该记录所在记录组中的第一条记录的表\r\n项， 然后在组内进行顺序查找， 由于组内的数据量不多， 所以组内顺序查找开销\r\n很小。 有关效率的分析见P212， 这种分组索引的方式， 对检索巨量数据是很有效\r\n的。', '0');
INSERT INTO `question_answer` VALUES ('168', '从检索速度和存储费用两方面来比较两级索引文件和索引顺序文件有什么不同?', '假设主文件拥有N条记录。\r\n对于索引文件， 主文件的每条记录均需配置一个索引项， 故索引存储开销为\r\nN； 而为检尜到具有指定关键字的记录， 对分查找平均需要查找约log2（n） 条记\r\n录。 对于索引顺序文件， 假如为每100个记录分组配置一个索引项， 故索引存储\r\n开销为log2（n/100） +100/2条记录； 而为检索到具有指定关键字的记录， 平均\r\n需要查找N/200+50条记录。 对于更大的数据量， 还可以两级索引顺序文件。', '0');
INSERT INTO `question_answer` VALUES ('169', '对目录管理的主要要求是什么?', '(1） 实现“按名存取” ；\r\n(2） 提高对目录的检索速度；\r\n(3） 文件共享；\r\n(4） 允许文件重名。', '0');
INSERT INTO `question_answer` VALUES ('170', '采用单级目录能否满足对目录管理的主要要求?为什么?', '采用单级目录不能完全满足对目录管理的主要要求， 只能实现目录管理最基\r\n本的功能即按名存取。 由于单级目录结构采用的是在系统只配置一张目录表用来\r\n记录系统中所有文件的相关信息， 因此此目录文件可能会非常大， 在查找时速度\r\n慢， 另外不允许用户文件有重名的现象， 再者由于单级目录中要求所有用户须使\r\n用相同的名字来共享同一个文件， 这样又会产生重名问题， 因此不便于实现文件\r\n共享。', '0');
INSERT INTO `question_answer` VALUES ('171', '目前广泛采用的目录结构形式是哪种?它有什么优点?', 'a. 能有效提高对目录的检索速度； 假定文件系统中有N个文件， 在单级目\r\n录中， 最多要检索N个目录项， 但对于有i级的树型目录， 在目录中每检索一个\r\n指定文件， 最多 可能要检索 个目 录项。\r\nb. 允许文件重名； 由于在树型结构的文件系统中， 是利用文件路径名来\r\n检索文件的， 故允许每个用户在自己的分目录中使用与其他用户文件相同的名字。\r\nc. 便于实现文件共享； 在树型目录中， 用户可通过路径名来共享其他用\r\n户的文件， 也可将一个共享文件链接到自己的目录下， 从而使文件的共享变得更\r\n为方便， 其实现方式也非常简单， 系统只需在用户的目录文件中增设一个目录项，\r\n填上用户赋予该共享文件的新文件名， 以及该共享文件的唯一标识符即可。', '0');
INSERT INTO `question_answer` VALUES ('172', '某操作系统的磁盘文件空间共有500块， 若用字长为32位的位示图管\r\n理磁盘空间， 试问：\r\n(1)位示图需要多少字？\r\n(2)第i字第j位对应的块号是多少？\r\n(3) 给出申请/归还一块的工作流程。', '[500/32]z=16个字\r\nb=（i-l） *32+j=32（i-1） +j（b从1开始计数， i， j也从1开始计数） 根据\r\n盘块号b求出：\r\ni=（b-l） /32+1； j=（b-l） %32+1；\r\n将第i字第j位置0', '0');
INSERT INTO `question_answer` VALUES ('173', 'Hash 检索法有何优点?又有何局限性?', '在Hash检索法中， 系统利用用户提供的文件名并将它变换为文件目录的索引\r\n值， 再利用该索引值到目录中去查找， 这样能有效地提高目录的检索速度， 但H\r\nash检索法也有局限性即对于使用了通配符的文件名， 系统是无法使用Hash检索\r\n法检索目录的。', '0');
INSERT INTO `question_answer` VALUES ('174', '在Hash检索法中,如何解决“冲突\"问题?', '1、开放定址法\r\n    　用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。', '0');
INSERT INTO `question_answer` VALUES ('175', '基于索引结点的文件共享方式有何优点?', '由于原来的文件物理地址等信息是放在目录项中的，似的文件增加的部分不能被共享。引入索引结点后，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。在索引结点中设有一个连接计数count字段，用于表示链接到本索引接结点的目录项的数目，通过这种方式可以方便的实现文件的共享。', '0');
INSERT INTO `question_answer` VALUES ('176', '什么是主父目录和链接父目录?如何利用符号链实现共享?', '父目录是当前所在目录的上一层目录（文件夹\r\n转到父目录是转到当前所在目录的上一层目录。', '0');
INSERT INTO `question_answer` VALUES ('177', '基于符号链的文件共享方式有何优点?', '在于“建立新的共享链接，并不改变文件拥有者的关系，仅把索引结点共享计数器加1，所以系统可方便获悉由多少个目录项指向该文件”', '0');
INSERT INTO `question_answer` VALUES ('178', '什么是保护域?进程与保护域之间存在着的动态联系是什么?', '保护域是进程对一组对象访问权的集合，规定了进程能访问对象和执行的操作。\r\n\r\n进程与保护域之间的动态联系是指进程的可用资源集在个生命周期中是变化的；进程运行在\r\n\r\n不同的阶段可以根据需要从一个保护域切换到另一个保护域。', '0');
INSERT INTO `question_answer` VALUES ('179', '如何利用拷贝权来扩散某种访问权?', '如果域i 具有对象j 的某访问权acess(i,j)的拷贝权，则运行在域i的进程可将其访问权\r\n\r\nacess(i,j)扩展到访问矩阵同一列中的其它域，即为运行在其它域的进程也赋予关于同一对象\r\n\r\n的同样访问（acess(i,j)）。', '0');
INSERT INTO `question_answer` VALUES ('180', '如何利用拥有权来增,删某种访问权?', '如果域i 具有关于对象j 的所有权，则运行在域i 的进程可以增删在j 列的任何项中的\r\n\r\n任何访问权。或该进程可以增删在任何其它域中运行的进程关于对象j的任何访问权。', '0');
INSERT INTO `question_answer` VALUES ('181', '增加控制权的主要目的是什么?', '控制权用于改变某个域中运行进程关于不同对象的访问权。', '0');
INSERT INTO `question_answer` VALUES ('182', '什么是访问控制表?', '：访问控制表是指对访问矩阵按列划分，为每列建立一张访问控制表ACL，由有序对（域，\r\n\r\n权集）组成，用来保证系统安全性的一种手段。', '0');
INSERT INTO `question_answer` VALUES ('183', '什么是访问权限表?', '访问权限表是指对访问矩阵按行划分，由每行构成一张访问权限表。', '0');
INSERT INTO `question_answer` VALUES ('184', '系统如何利用访问控制表和访问权限表来实现对文件的保护?', '当进程第一次试图访问一个对象时，必须先检查访问控制表，查看是否有权访问该对象。\r\n\r\n如果无则拒绝访问，并构成一个例外异常事件；否则便允许访问，并为之建立访问权限，以\r\n\r\n便快速验证其访问的合法性。当进程不再访问该对象时便撤销该访问权限。', '0');
INSERT INTO `question_answer` VALUES ('185', '目前常用的外存有哪几种组织方式?', '(1) 连续组织方式。 为每一个文件分配一组位置相邻接的盘块， 由此形成的文件\r\n物理结构是顺序式的文件结构。\r\n(2) 链接组织方式。 为每个文件分配一组位置离散的盘块， 通过给每个盘块设置\r\n一个指针， 将属于同一个文件的盘块链接在一起， 链接的顺序和文件的逻辑页的\r\n顺序一致。 由此形成的文件物理结构是链接文件。\r\n(3) 索引组织方式。 为每个文件分配一组位置离散的盘块， 为每个文件建立一个\r\n物理结构的索引表， 记录分配给该文件的物理盘块， 以及这些盘块和文件逻辑页\r\n顺序的对应关系。 由此形成的文件物理结构是索引文件。', '0');
INSERT INTO `question_answer` VALUES ('186', '在某FAT16文件系统中，FAT表的每个表项用16位表示，每**簇（即，块）**64扇区，扇区的大小为512字节。\r\n  该分区最大可为多少字节？\r\n  其FAT占用多少存储空间？', '16位能索引216个块，一个块大小是：64*512=215字节，216+15=231字节，即该分区最大可位2GB大小，一个表项16位，即2个字节，216个表项共占217字节大小，即128KB。', '0');
INSERT INTO `question_answer` VALUES ('187', '在链接式文件中常用哪种链接方式?', '链接方式分为隐式链接和显式链接两种形式。隐式链接是在文件目录的每个目录项中，都含有指向链接文件第一个盘块和最后一个盘块的指针。显式链接则把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。', '0');
INSERT INTO `question_answer` VALUES ('188', '在文件分配表中为什么要引入“簇”的概念?以“簇”为基本的分配单位有什么好处?', '微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位叫做“簇”\r\n一个文件通常存放在一个或多个簇里，但至少要单独占据一个“簇”。 也就是说两个文件不能存放在同一个簇中。\r\n簇（CLUST）的本意就是“一群”、“一组”，即一组扇区(一个磁道可以分割成若干个大小相等的圆弧，叫扇区)的意思。因为扇区的单位太小，因此把它捆在一起，组成一个更大的单位更方便进行灵活管理。簇的大小通常是可以变化的，是由操作系统在所谓“（高级）格式化”时规定的，因此管理也更加灵活。', '0');
INSERT INTO `question_answer` VALUES ('189', '为什么要从FAT12发展为FAT16?又进一步要发展为FAT32?', 'at16--fat32--NTFS\r\n \r\n文件越来越大，程序越来越大，硬盘越来越大，\r\n \r\n便要求更大分区，更安全，更优化的分区格式', '0');
INSERT INTO `question_answer` VALUES ('190', 'NTFS 文件系统中的文件所采用的是什么样的物理结构?', '在NTFS文件系统中，以簇作为磁盘空间分配和回收的基本单位。一个文件占若干个簇，一个簇只属于一个文件。', '0');
INSERT INTO `question_answer` VALUES ('191', '什么是索引文件?为什么要引入多级索引?', '索引文件是指当记录为可变长度时，通常为之建立一张索引表，并为每个记录设置一个表项构成的文件。通常将索引非顺序文件简称为索引文件。索引是为了是用户的访问速度更快，多级索引结构可以有效的管理索引文件，可根据用户的访问情况多级处理。', '0');
INSERT INTO `question_answer` VALUES ('192', 'FAT占用那么多内存可不行，有没有缓解方案？', '可以将部分FAT放磁盘上鸭，但是会使索引效率降低。也可以适用大一点的block，那么保存小文件就很浪费空间了~！所以说FAT还不是很好，我们还需要继续改进！', '0');
INSERT INTO `question_answer` VALUES ('193', '对空闲磁盘空间的管理常采用哪几种分配方式?在UNIX 系统中是采用何种分配方式?', '空闲表法、空闲链表法、位示图法、成组链接法。UNIX系统采用的是成组链接法', '0');
INSERT INTO `question_answer` VALUES ('194', '可从哪几方面来提高对文件的访问速度?', '(1) 改进文件的目录结构以及检索目录的方法来减少对目录的查找时间；\r\n(2) 选择好的文件存储结构；\r\n(3) 提高磁盘的 I/O 速度， 能将文件中的数据块快速地从磁盘传送到内存， 或相\r\n反。', '0');
INSERT INTO `question_answer` VALUES ('195', '何谓磁盘高速缓存?在设计磁盘高速缓存时需要考虑哪些问题?', '磁盘高速缓冲是指利用内存中的存储空间，暂存从磁盘中读出的一系列盘块中的信息。数据交付是指将磁盘高速缓存中的数据传给请求进程。当进程请求访问某个盘块中的数据时，由核心先查看磁盘高速缓冲，看其中是否存在所需盘块数据的拷贝。若有便直接从中提取数据交付给请求进程，避免了访盘操作，本次访问速度提高4-6个数量级；否则先从磁盘中将要访问的数据读入并交付给请求者进程，同时送高速缓存以便下次直接读取。', '0');
INSERT INTO `question_answer` VALUES ('196', '什么是先来先服务?', '是一种简单、公平、低效的方法：访问顺序是：55,58,39,18,90,160,150,38,18\r\n磁臂移动距离：45+3+19+21+72+70+10+112+20', '0');
INSERT INTO `question_answer` VALUES ('197', '何谓提前读和延迟写?', '虚拟盘又称RAM盘，是利用内存空间仿真磁盘。其设备驱动程序可以接受所有标准的磁盘操作，但这些操作不是在磁盘上而是在内存中，因此速度更快。', '0');
INSERT INTO `question_answer` VALUES ('198', '什么是RAID?', '磁盘阵列(Redundant Arrays of Independent Disks，RAID)，有\"独立磁盘构成的具有冗余能力的阵列\"之意。', '0');
INSERT INTO `question_answer` VALUES ('199', '在第一级系统容错技术中,包括哪些容错措施?', '一级系统容错技术包括双份目录、双份文件分配表及写后读校验等容错措施。\r\n\r\n写后读校验是每次从内存缓冲区向磁盘写入一个数据块后，又立即从磁盘上读出该数据块，并送至另一缓冲区中，再将该缓冲区内容与内存缓冲区中在写后仍保留的数据进行比较。若两者一致，才认为写入成功，继续写下一个盘块。否则重写。若重写后仍不一致，则认为盘块缺陷，便将应写入该盘块的数据，写入到热修复重定向区中。', '0');
INSERT INTO `question_answer` VALUES ('200', 'RALD的主要优点有什么？', '磁盘阵列还能利用同位检查(Parity Check)的观念，在数组中任意一个硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。', '0');
INSERT INTO `question_answer` VALUES ('201', '在第二级系统容错技术中,包括哪些容错措施?', '第二级容错技术包括磁盘镜像和磁盘双工两种容错措施。', '0');
INSERT INTO `question_answer` VALUES ('202', '容错功能是什么? ', '在磁盘RAID技术中，RAID 1和RAID 5可以提供容错功能，利用该功能，计算机将数据写入多个磁盘，当有一个磁盘发生故障时，仍能保证信息的可用性。 \r\n在磁盘RAID技术中，RAID 1和RAID 5可以提供容错功能，利用该功能，计算机将数据写入多个磁盘，当有一个磁盘发生故障时，仍能保证信息的可用性。 \r\n在磁盘RAID技术中，RAID 1和RAID 5可以提供容错功能，利用该功能，计算机将数据写入多个磁盘，当有一个磁盘发生故障时，仍能保证信息的可用性。 \r\n', '0');
INSERT INTO `question_answer` VALUES ('203', '后备系统是什么?', ' 通过电子工程专辑网站专业编辑提供后备系统的最新相关信息,掌握最新的后备系统的最新行业动态资讯、技术文萃、电子资料,帮助电子工程师自我提升的电子技术平台.', '0');
INSERT INTO `question_answer` VALUES ('204', '何谓事务?如何保证事务的原子性?', '事务是用于访问和修改各种数据项的一个程序单位。\r\n\r\n要保证事务的原子性必须要求一个事务在对一批数据执行修改操作时，要么全部完成，\r\n\r\n用修改后的数据代替原来数据，要么一个也不改，保持原来数据的一致性。', '0');
INSERT INTO `question_answer` VALUES ('205', '引入检查点的目的是什么?引入检查点后又如何进行恢复处理?', '引入检查点的目的是使对事务记录表中事务记录的清理工作经常化。\r\n\r\n恢复处理由恢复例程来实现。首先查找事务记录表，确定在最近检查点以前开始执行的\r\n\r\n最后的事务Ti。找到Ti后再返回搜索事务记录表，找到第一个检查点记录，从该检查点开\r\n\r\n始，返回搜索各个事务记录，利用redo和undo 过程对他们进行相应的处理。', '0');
INSERT INTO `question_answer` VALUES ('206', '为何引入共享锁? 如何用互斥锁或共享锁来实现事务的顺序性?', '引入共享锁是为了提高运行效率。在给对象设置了互斥锁和共享锁的情况下，如果事务Ti要对Q执行读操作，只需获得Q的共享锁。如果对象Q已被互斥锁锁住，则Ti必须等待；否则便获得共享锁对Q执行读操作。如果Ti要对Q 执行写操作，则Ti还要获得Q的互斥锁。若失败则等待；成功则获得互斥锁并对Q执行写操作。', '0');
INSERT INTO `question_answer` VALUES ('207', '当系统中有重复文件时,如何保证它们的一致性?', '可以采用两种方法：一是对所有的重复文件进行同样的修改，二是用新修改的文件替换所有的重复文件。', '0');
INSERT INTO `question_answer` VALUES ('208', '如何检查盘块号的一致性? 检查时可能出现哪几种情况?', '为了保证盘块号的一致性，先将计数器表中的所有表项初始化为0，用N 个空闲盘块\r\n\r\n号计数器组成的第一组计数器对从空闲盘块表中读出的盘块号计数，用N 个数据盘块号计\r\n\r\n数器组成的第二组计数器对从文件分配表中读出的已分配给文件使用的盘快号计数。如果两组计数中的对应数据互补则数据一致，反之则发生错误。\r\n\r\n检查时可能出现的情况：\r\n\r\n（1）两组计数器中盘块K 的计数值均为0，应在空闲盘块表中增加盘块号K；\r\n\r\n（2）空闲盘块号计数器中盘块K 的计数值为2，应删除一个空闲盘块号K；\r\n\r\n（3）空闲盘块号计数器中盘块号K 的计数值为0，而数据盘块号计数器中盘块号K 的\r\n\r\n计数值大于1，则错误严重，存在数据丢失等事件，必须立即报告系统加以处理。', '0');
INSERT INTO `question_answer` VALUES ('209', '操作系统用户接口中包括哪几种接口? 它们分别适用于哪种情况?', '操作系统包括四种类型的用户接口：命令接口（分为联机与脱机命令接口）、程序接口、图形化用户接口和网络用户接口。\r\n\r\n命令接口和图形化用户接口支持用户直接通过终端来使用计算机系统，程序接口提供给用户在编制程序时使用，网络用户接口是面向网络应用的接口。', '0');
INSERT INTO `question_answer` VALUES ('210', '什么是WIMP 技术? 它被应用到何种场合?', '在人机互动领域之中最普遍的电脑互动界面，WIMP堪称无人能出其右，举凡微软的Windows、苹果电脑的MacOS，甚至其它以X Window系统为基础的操作系统，均采用WIMP此一界面典范。WIMP是由\"视窗\"(Window)、\"图标\"(Icon)、\"选单\"(Menu)以及\"指标\"(Pointer)所组成的缩写，其命名方式也指明了它所倚赖的四大互动元件。', '0');
INSERT INTO `question_answer` VALUES ('211', '联机命令通常有哪几种类型?每种类型中包括哪些主要命令?', '联机命令接口由一组联机命令、终端处理程序和命令解释程序构成。', '0');
INSERT INTO `question_answer` VALUES ('212', '什么是输入输出重定向?', '命令的输入通常取自标准输入设备键盘，命令输出则送往标准输出设备显示终端。如果在命令中设置输出定向“>”，其后接文件或设备名，则命令的结果输出将送到指定文件或设备上；如果使用输入重定向“<”，则不从键盘而是从重定向符右边的指定文件或设备上取得输入信息。这就是输入输出的重定向。', '0');
INSERT INTO `question_answer` VALUES ('213', '何谓管道联接? ', '管道联接是指把第一个命令的输出作为第二个命令的输入，或把第二个命令的输出作为\r\n\r\n第三条命令的输入，以此类推，由两条以上的命令可形成一条管道。在MS-DOS和UNIX\r\n\r\n中，都用\"|\"作为管道符号。其一般格式为：command1 |command2 | …|commandn。', '0');
INSERT INTO `question_answer` VALUES ('214', '为了将已存文件改名,应用什么UNIX命令?', '对已存文件改名的命令为mv，其格式为：mv oldname newname。', '0');
INSERT INTO `question_answer` VALUES ('215', '要想将工作目录移到目录树的某指定结点上,应使用什么命令?', '用命令“cd ..”或“cd .”将当前目录上移或转移，直到工作目录移到目录树的指定点。', '0');
INSERT INTO `question_answer` VALUES ('216', '如果希望把file1的内容附加到原有的文件file2的末尾,应用什么命令?', ' $catfile1>>file4', '0');
INSERT INTO `question_answer` VALUES ('217', '试比较 mail和write命令的作用有何不同?', 'mail命令作为UNIX 的多用户之间非交互式通信的工具。write命令是用户与当前系统\r\n\r\n中的其他用户直接进行联机通讯的工具。', '0');
INSERT INTO `question_answer` VALUES ('218', '联机命令接口由哪几部分组成?', '联机命令接口包括:一组联机命令，终端处理程序、命令解释程序。', '0');
INSERT INTO `question_answer` VALUES ('219', '终端设备处理程序的主要作用是什么?', '主要用于实现人机交互，它具有以下功能：\r\n\r\n（1）接收用户从终端上键入的字符；（2）字符缓冲，用于暂存接收的字符；（3）回送显示；（4）屏幕编辑； （5）特殊字符处理。', '0');
INSERT INTO `question_answer` VALUES ('220', '命令解释程序的主要功能是什么?', '主要作用是：在屏幕上给出提示符，请用户输入命令，读入并识别命令，转至相应命令处理程序入口地址，把控制权交给该处理程序执行，最后将处理结果或出错信息送屏幕显示。', '0');
INSERT INTO `question_answer` VALUES ('221', 'MS-DOS 的命令处理程序 COMMAND.COM的工作流程是什么?', '（1）系统通电或复位后，初始化程序对整个系统完成初始化工作，自动执行Autoexec.bat文件，然后把控制权交给暂存部分，给出提示符等待接收用户键入命令；\r\n\r\n（2）暂存部分读入键盘缓冲区中的命令，判别文件名、扩展名及驱动器名是否正确，若有错则出错返回，正确则查找和识别命令；\r\n\r\n（3）若为内部命令，暂存部分找到后便从对应表项中获得命令处理程序的入口地址并执行；若为外部指令，则建立命令行，执行系统调用exec装入其命令处理程序，得到对应基地址并执行；若键入命令非法，则出错返回；\r\n\r\n（4）命令完成后，控制权重新交给暂存部分给出提示符等待接收用户命令，转（2）。', '0');
INSERT INTO `question_answer` VALUES ('222', '如何运行Shell命令?', '1、shell的内建命令，用户可以直接输入命令名称执行。比如pwd、cd等命令。用户可以通过type命令来判断命令是内建命令还是外部命令。2、shell的外部命令，shell程序会根据PATH变量中的路径查找相应的外部命令，如果命令在PATH变量的路径中，用户可以直接输入命令名称来执行，比如cat、grep、ping等都是外部命令。\r\n3、如果shel外部命令不在PATH环境变量的路径中，则需要通过“.”命令来执行程序或者脚本文件。', '0');
INSERT INTO `question_answer` VALUES ('223', '如何建立二叉树结构的命令行树?', '（1）随机创建一棵二叉树（2）根据二叉树的前序、中序或后序序列（同时包含空节点的序列）来创建（3）根据二叉树对应的“完全二叉树”序列来创建（设下标从0开始）（4）由遍历序列创建二叉树 link(public)，这个已经单独介绍过了，包括给定中序前序创建和给定中序后序创建两种情况。', '0');
INSERT INTO `question_answer` VALUES ('224', '一般的过程调用与系统调用有什么区别?', '系统调用本质上是过程调用的一种特殊形式，与一般过程调用有差别：\r\n\r\n（1）运行状态不同。一般过程调用的调用过程和被调用过程均为用户程序，或者均为系统程序，运行在同一系统状态（用户态或系统态）；系统调用的调用过程是用户态下的用户程序，被调用过程是系统态下的系统程序。\r\n\r\n（2）软中断进入机制。一般的过程调用可直接由调用过程转向被调用过程；而系统调用不允许由调用过程直接转向被调用过程，一般通过软中断机制，先进入操作系统内核，经内核分析后，才能转向相应命令处理程序。\r\n\r\n（3）返回及重新调度。一般过程调用在被调用结束后，返回调用点继续执行；系统调用被调用完后，要对系统中所有运行进程重新调度。只有当调用进程仍具有最高优先权才返回调用过程继续执行。\r\n\r\n（4）嵌套调用。一般过程和系统调用都允许嵌套调用，注意系统过程嵌套而非用户过程。', '0');
INSERT INTO `question_answer` VALUES ('225', '系统调用有哪几种类型?', '（1）进程控制类（2）文件操纵类（3）进程通信类（4）信息维护类', '0');
INSERT INTO `question_answer` VALUES ('226', '如何设置系统调用所需的参数?', '（1）设置系统调用号和参数。\r\n\r\n（2）对系统调用命令的一般性处理。如保护CPU现场，PSW、PC、系统调用号、用户栈指针及通用寄存器入栈，保存用户定义参数等。UNIX中执行CHMK 命令将参数表中的参数传到User结构的U.U-arg()中；MS-DOS执行INT21软中断。\r\n\r\n（3）根据系统调用入口表及具体系统调用命令转至对应命令处理程序具体处理。', '0');
INSERT INTO `question_answer` VALUES ('227', ' 什么是系统调用？', '系统调用是操作系统提供给编程人员的唯一接口。 编程人员利用系统\r\n调用， 在源程序一级动态请求和释放系统资源， 调用系统中已有的系统功\r\n能来完成那些与机器硬件部分相关的工作以及控制程序的执行速度等。', '0');
INSERT INTO `question_answer` VALUES ('228', '为什么在访问文件之前,要用 open 系统调用先打开该文件?', '系统将在用户与该文件之间建立一条快捷通路。在文件被打开后，系统将给用户返回一\r\n\r\n个该文件的句柄或描述符。', '0');
INSERT INTO `question_answer` VALUES ('229', '在UNIX系统中是否设置了专门用来删除文件的系统调用?为什么?', '没有。当用户不再使用此文件时，利用系统调用unlink断开连接，做i.link减1操作。\r\n\r\n当i.link减1结果为0，表示此文件不再被用户需要，该文件将从文件系统中删除。', '0');
INSERT INTO `question_answer` VALUES ('230', '在IPC 软件包中包含哪几种通信机制?在每种通信机制中设置了哪些系统调用?', ' IPC 中提供了三种通信机制：\r\n\r\n（1）消息机制。存在msgget,msgsend,msgrcv 系统调用。\r\n\r\n（2）共享存储器机制。存在shmget,shmid,shmdt 系统调用。\r\n\r\n（3）信号量机制。无系统调用。', '0');
INSERT INTO `question_answer` VALUES ('231', 'trap.S是什么程序?它完成哪些主要功能?', 'UNIX系统V 内核中的trap.S文件，是中断和陷入总控程序。用于中断和陷入的一般\r\n\r\n性处理，由汇编语言编写。trap.S 中包含了绝大部分的中断和陷入向量的入口地址，每当\r\n\r\n系统发生中断和陷入时，通常都是直接进入trap.S程序。', '0');
INSERT INTO `question_answer` VALUES ('232', '在UNIX系统内,被保护的 CPU环境中包含哪些数据项?', '当用户程序处在用户态且执行CHMK (CHange Mode toKernel）之前，应在用户空间提供系统调用所需参数表，并将参数表地址送入R0寄存器。执行CHMK命令后，处理机转为核心态，由硬件自动将处理机状态长字(PSL)、PC和代码操作数(code)压入用户核心栈，从中断和陷入向量表中取出trap.S入口地址，转入trap.S中执行。\r\n\r\ntrap.S 程序执行后，将陷入类型type 和用户栈指针usp压入用户核心栈，将被中断进程的CPU环境中的一系列寄存器如R0～R11的部分或全部压栈。哪些寄存器内容压栈，取决于特定寄存器的屏蔽码，屏蔽码每一位都与R0～R11中的寄存器相对应。当某一位置1时，表示对应寄存器内容压栈。', '0');
INSERT INTO `question_answer` VALUES ('233', 'trap.C是什么程序?它将完成哪些处理?', '：trap.C 程序是处理各种陷入情况的C 语言文件，共处理12种陷入后的公共问题。包括：确定系统调用号、实现参数传递、转入相应系统调用处理子程序。在由系统调用子程序返回到trap.C后，重新计算进程的优先级，对收到的信号进行处理等。', '0');
INSERT INTO `question_answer` VALUES ('234', '为方便转入系统调用处理程序,在UNIX系统中配置了什么样的数据结构?', '在UNIX系统中配置了系统调用定义表sysent[]，在表的每个结构中包含三个元素，一是相应系统调用所需参数的个数；二是系统调用经寄存器传送的参数个数；三是相应系统调用处理子程序的入口地址。系统中设置了该表之后，可根据系统调用号i从系统调用定义表中找出相应表目，按表目中的入口地址转入相应处理子程序，完成系统调用的特定功能。执行完后，返回中断和陷入总控程序中的trap.C程序中，返回断点前的公共处理部分。', '0');
INSERT INTO `question_answer` VALUES ('235', '什么是CPU 时钟频率?', 'CPU的主频，即CPU内核工作的时钟频率（CPU Clock Speed）。通常所说的某某CPU是多少兆赫的，而这个多少兆赫就是“CPU的主频”。', '0');
INSERT INTO `question_answer` VALUES ('236', '引入多处理机系统的原因有哪些?', '多处理器系统分类中，对称式多处理器系统符合哪些特征\r\n 1、紧密耦合 \r\n2、共享内存 \r\n3、在一台处理器上执行操作系统，其他处理器执行应用进程 \r\n4、各个处理器的地位都完全相同 ', '0');
INSERT INTO `question_answer` VALUES ('237', '什么是紧密耦合MPS和松弛耦合MPS?', '松耦合方式:在一个Converged应用中，SIP Servlet和HTTP Servlet(或其他J2EE编程模式)分别独立实现，各自执行独立的功能，代码中没有互相调用，两种类型的Servlet上下文及相关配置分别在 sip.xml和web.xml文件中指定。如果需要互相配合，则由第三者来控制它们之间的互相访问。PersonalAssistant即属于这种方式。 紧耦合方式:在一个Converged应用中，SIP Servlet和HTTP Servlet(或其他J2EE编程模式)分别独立实现，但二者之间可以互相访问，通常是在HTTP Servlet中去访问SIP Servlet。', '0');
INSERT INTO `question_answer` VALUES ('238', '何谓UMA多处理机结构?', '对称多处理机，在均匀存储器访问(UMA)系统中，一个共享存储器可以为所有处理器通过一个互联网络进行访问，就如同一个单处理器访问它的存储器一样。所有处理器对任何存储单元有相同的访问时间。用于UMA中的互联网络可以是单总线、多总线或者是交叉开关。因为对共享存储器的访问是平衡的，故这类系统成为SMP(对称多处理器)系统。每个处理器有相等的机会读/写存储器，也有相同的访问速度。', '0');
INSERT INTO `question_answer` VALUES ('239', '什么是NUMA多处理机系统结构?', '1.容错性 2.并行性 3.分布性', '0');
INSERT INTO `question_answer` VALUES ('240', '什么是CPU缓冲?', '在计算机系统中，CPU高速缓存(英语:CPU Cache，在本文中简称缓存)是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。', '0');
INSERT INTO `question_answer` VALUES ('241', '处理机的功能是什么?', ' 处理机管理的主要功能是： 进程管理、 进程同步、 进程通信和处理机调度；', '0');
INSERT INTO `question_answer` VALUES ('242', '为什么需要进程？', '在单道程序系统中，程序只能够顺序的执行，即两个程序只能等一个执行完再执行下一个。这样就使程序的执行具有三个特型：顺序性、封闭性和可再现性。而到了多道程序系统中，允许程序并发的执行（宏观并行，微观串行）。此时程序并发执行就具有了：间断性、失去封闭性和不可再现性。为了解决程序并发执行的问题', '0');
INSERT INTO `question_answer` VALUES ('243', '多处理机OS是?', '多个处理机(器)在物理位置上处于同一机壳中，有一个单一的系统物理地址空间和每一个处理机均可访问系统内的所有存储器是它的特点。', '0');
INSERT INTO `question_answer` VALUES ('244', '何谓分布式数据处理?', '由于个人计算机的性能得到极大的提高及其使用的普及，使处理能力分布到网络上的所有计算机成为可能。分布式计算是和集中式计算相对立的概念，分布式计算的数据可以分布在很大区域。\r\n分布式网络中，数据的存储和处理都是在本地工作站上进行的。数据输出可以打印，也可保存在软盘上。通过网络主要是得到更快、更便捷的数据访问。因为每台计算机都能够存储和处理数据，所以不要求服务器功能十分强大，其价格也就不必过于昂贵。这种类型的网络可以适应用户的各种需要，同时允许他们共享网络的数据、资源和服务。在分布式网络中使用的计算机既能够作为独立的系统使用，也可以把它们连接在一起得到更强的网络功能。', '0');
INSERT INTO `question_answer` VALUES ('245', '集中式具有哪些特征?', ' 集中式数据存储的主要特点是能把所有数据保存在一个地方，各地办公室的远程终端通过电缆同中央计算机（主机）相联，保证了每个终端使用的都是同一信息。备份数据容易，因为他们都存储在服务器上，而服务器是唯一需要备份的系统。这还意味这服务器是唯一需要安全保护的系统，终端没有任何数据。银行的自动提款机（ATM）采用的就是集中式计算机网络。另外所有的事务都在主机上进行处理，终端也不需要软驱，所以网络感染病毒的可能性很低。这种类型的网络总费用比较低，因为主机拥有大量存储空间、功能强大的系统，而使终端可以使用功能简单而便宜的微机和其他终端设备。', '0');
INSERT INTO `question_answer` VALUES ('246', '什么是进程？', ' 进程是程序的一次执行，是资源分配和调度的基本单位。进程 = 程序 + 数据 + 程序控制块(Process Control Block，PCB)。', '0');
INSERT INTO `question_answer` VALUES ('247', '什么是自旋锁?', '自旋锁是一种基础的同步原语，用于保障对共享数据的互斥访问。与互斥锁的相比，在获取锁失败的时候不会使得线程阻塞而是一直自旋尝试获取锁。当线程等待自旋锁的时候，CPU不能做其他事情，而是一直处于轮询忙等的状态。自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。', '0');
INSERT INTO `question_answer` VALUES ('248', '读一拷贝一修改锁(RCU)原理?', 'RCU(Read-Copy Update)，顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它 时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。', '0');
INSERT INTO `question_answer` VALUES ('249', '何谓二进制指数退避算法?', 'CSMA/CD采用二进制指数退避算法，又称为二元指数后退算法。退避算法是以冲突窗口大小为基准的，每个节点有一个冲突计数器C。退避的时间与冲突次数具有指数关系，冲突次数越多，退避的时间就可能越长，若达到限定的冲突次数，该节点就停止发送数据。', '0');
INSERT INTO `question_answer` VALUES ('250', '时间邮戳定序机构和事件计数的作用是什么?', '时间邮戳定序机构(TimestampOrderingMechanism)对时间邮戳定序机构最基本的要求是在系统中应具有唯一的', '0');
INSERT INTO `question_answer` VALUES ('251', '什么是任务调度?', '任务调度，简单来说就是定时任务，是指基于给定时间点，给定时间间隔或者给定执行次数自动执行任务。', '0');
INSERT INTO `question_answer` VALUES ('252', '多处理机系统中静态分配方式和动态分配方式有什么区别?', '一是时间不同。静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。\r\n\r\n二是空间不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由函数malloc进行分配。不过栈的动态分配和堆不同，他的动态分配是由编译器进行释放，无需我们手工实现。', '0');
INSERT INTO `question_answer` VALUES ('253', '进程调度算法的优缺点?', '1、时间片轮转调度算法（RR）：给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。\r\n\r\n2、先来先服务调度算法（FCFS）：根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。\r\n\r\n3、优先级调度算法（HPF）：在进程等待队列中选择优先级最高的来执行。常被用于批处理系统中，还可用于实时系统中。\r\n\r\n4、多级反馈队列调度算法：将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。\r\n\r\n5、高响应比优先调度算法：根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。', '0');
INSERT INTO `question_answer` VALUES ('254', '何谓成组技术?', '成组技术(GT-group technology)揭示和利用事物间的相似性，按照一定的准则分类成组，同组事物能够采用同一方法进行处理，以便提高效益的技术，称为成组技术。它已涉及各类工程技术、计算机技术、系统工程、管理科学、心理学、社会学等学科的前沿领域。日本、美国、苏联和联邦德国等许多国家把成组技术与计算机技术、自动化技术结合起来发展成柔性制造系统，使多品种、中小批量生产实现高度自动化。全面采用成组技术会从根本上影响企业内部的管理体制和工作方式，提高标准化、专业化和自动化程度。在机械制造工程中，成组技术是计算机辅助制造的基础，将成组哲理用于设计、制造和管理等整个生产系统，改变多品种小批量生产方式，以获得最大的经济效益。', '0');
INSERT INTO `question_answer` VALUES ('255', '多处理器调度是?', '多处理器调度是根据处理器调度策略每次取出一个任务，将任务分配到处理器上运行的方法。多处理器调度包括给处理器分配进程、在单个处理器上是否使用多道程序技术、实际分派进程三个相关的方面。多处理器系统中线程调度通常有负载共享、成组调度、专用处理器分配、动态调度四种方式。', '0');
INSERT INTO `question_answer` VALUES ('256', '为什么要专用处理器调度方式', '这是成组调度的极端形式。当一个进程被调度时，它的每个线程被分配到一个处理器上，在该进程完成之前，处理器由相应的线程专用。\r\n这种方法会浪费处理器的时间。当一个线程为了与另一个线程同步而等待I/O时，该线程专用的处理器就闲置了。但是，在由几十甚至上百个处理器组成的高度并行系统中，处理器的利用率不再是最重要的问题。此外，在一个应用程序的生存期中完全避免了进程切换，因而大大加速了程序的执行。', '0');
INSERT INTO `question_answer` VALUES ('257', '多媒体文件有哪些特点?', '集成性、控制性、交互性、非线性、实时性、信息使用的方便性、信息结构的动态性。', '0');
INSERT INTO `question_answer` VALUES ('258', '多媒体的集成性包含了哪几方面的合义?', '多媒体的集成性是指能将多种媒体有机地组织在一起， 做到文字、声音、图形与图像等的一体化。其集成性主要表现 在两个方面：其一,多媒体信息的集成;其二，处理这些媒体信 息的工具和设备的集成。多媒体处理工具和设备的集成能够 为多媒体系统的开发与实现建立一个理想的集成环境。', '0');
INSERT INTO `question_answer` VALUES ('259', '在计算机系统中,为了进行图像、音频信号和视频信号的处理,需要增加哪些硬件?', '多媒体主机、多媒体输入设备、多媒体输出设备、多媒体存储设备、多媒体接口卡、人机交互设备', '0');
INSERT INTO `question_answer` VALUES ('260', '常用的数字音频文件有哪几种类型?', '1、CD；2、OGG；3、MP3；4、ASF、WMA；5、WAV；6、MP3PRO；7、RM；8、REAL；9、APE；10、MODULE；11、MIDI；12、VQF', '0');
INSERT INTO `question_answer` VALUES ('261', '彩色电视的制式有哪几种?我国采用的是哪一种?', 'TV制式 NTSC-M PAL-D SECAM\r\n帧频(Hz) 30 25 25\r\n行 / 帧 525 625 625\r\n亮度带宽(MHz) 4.2 6 6\r\n彩色幅载波(MHz) 3.58 4.43 4.25\r\n色度带宽(MHz) 1.3(I)，0.6(Q) 1.3(U)，1.3(V) >1.0(U)，>1.0(V)\r\n声音载波(MHz) 4.5 6.5 6.5\r\n我国采用的是PAL制式。', '0');
INSERT INTO `question_answer` VALUES ('262', '几种常用的MPEG标准有哪些?', 'MPEG标准主要有以下五个，MPEG-1、MPEG-2、MPEG-4、MPEG-7及MPEG-21等。', '0');
INSERT INTO `question_answer` VALUES ('263', '在多媒体系统中,对实时任务的处理有何需求?', '在多媒体系统中必须严格按照时间间隔对实时任务进行处理。', '0');
INSERT INTO `question_answer` VALUES ('264', '在多媒体系统中,进程管理中必须解决哪些问题?', '(1)同时运行不同类型的软实时任务：通常媒体服务器可向众多的用户提供各种多媒体服务，如数字电影和电视服务。多媒体进程管理必须具有能支持多种不同类型的软实时任务同时运行的能力。(2)支持软实时任务和非实时任务同时运行：一个具有多媒体功能的通用操作系统，它既应面向软实时任务的用户，又需面向非实时任务的用户，如交互型作业的用户。因此，在系统中，应当允许多种类型的SRT任务和不同类型的非实时任务井存。\r\n(3)提供适当的进程接纳机制：为了解决多道程序环境下在系统中同时运行多个SRT任务的截止时间需求和CPU利用率的矛盾，引入了对进程的接纳控制机制，目前常用的是基于预留的进程接纳机制。\r\n(4)采用实时调度算法：实时调度在保证SRT任务的实时性方面起着至关重要的作用。在具有多媒体功能的操作系统中，一个好的实时调度算法应能向每个SRT任务提供可以接受的截止时问保证，即能满足每一个SRT任务绝大多数的截止时间需求。', '0');
INSERT INTO `question_answer` VALUES ('265', '什么是SRT任务带宽和尽力而为任务带宽?为什么要设置这两种带宽?', 'SRT任务带宽是把CPU的一部分带宽分配给SRT任务运行。如果SRT任务被接纳了，它将获得一部分SRT任务带宽，进程管理便会尽可能地保证他们的实时性。\r\n   尽力而为任务带宽是如果SRT任务带宽未能被接纳，系统则有可能将该SRT任务分配到尽力而为任务带宽中运行，此时系统只是尽可能的让他们的得到运行的机会，但不做任何保证。\r\n   设置这两种带宽是为了能确保SRT任务的实时性，并适当考虑非实时任务的运行', '0');
INSERT INTO `question_answer` VALUES ('266', 'CPU代理的主要任务是什么?在什么情况下可以接收新进程?', 'CPU代理的主要任务是接收应用程序的接纳请求，根据接纳策略做出是否接纳的决定。', '0');
INSERT INTO `question_answer` VALUES ('267', '什么是预留策略?预留策略涉及哪些重要问题?', '针对资源预留过程中价格对市场竞争力的影响导致收益不确定性问题，提出一种可量化分析价格、资源竞争力以及收益三者关系的协同预留策略。', '0');
INSERT INTO `question_answer` VALUES ('268', '速率单调调度RMS算法里的优先级是如何确定的?', '当较低优先级的进程正在运行并且较高优先级的进程可以运行时，较高优先级进程将会抢占低优先级。在进入系统时，每个周期性任务会分配一个优先级，它与其周期成反比，即周期越短，优先级越高；周期越长，优先级越低。', '0');
INSERT INTO `question_answer` VALUES ('269', '.EDF算法与RMS调度算法有什么区别?', '任务按单调速率优先级分配（RMPA）的调度算法，称为单调速率调度（RMS）。RMPA是指任务的优先级按任务周期T来分配。它根据任务的执行周期的长短来决定调度优先级，那些具有小的执行周期的任务具有较高的优先级，周期长的任务优先级低。\r\nEDF是一种动态的调度算法。EDF全称Earliest Deadline First。EDF在调度时，任务的优先级根据任务的截止时间动态分配。截止时间越短，优先级越高。这种调度策略是最优的，已被证明所有负载小于等与1的任务集使用EDF都是是可调度的。', '0');
INSERT INTO `question_answer` VALUES ('270', '某文件系统空间的最大容量为4TB(1T=2的40次方)，以磁盘块为基本分配单位，磁盘块大小为1KB。文件控制块(FCB)包含一个512B的索引表。如果索引表只采用直接索引结构，存放文件占用的磁盘块号。在该文件系统中，单个文件最大长度为多少块?', '文件系统中磁盘块的块数：4TB/1KB=2(32)\r\n\r\n一个索引项至少32位才能对2(32)块磁盘块进行寻址，32bit=4B\r\n\r\n索引表中索引项的个数：512B/4B=128个，即一个文件占用了128块磁盘块', '0');
INSERT INTO `question_answer` VALUES ('271', '试比较一般的文件服务器和媒体服务器有什么区别?', '媒体服务器和网站（Web）服务器一样，要经受许多人的同时访问，相比Web服务器来说，由于多媒体文件需要更强处理能力， 其硬件设备应超越一般用于Web的服务器。所以，媒体服务器最好满足以下硬件条件。 \r\n一颗强劲的“芯”。\r\n占用系统资源少的声卡。\r\n良好的视频捕捉设备。\r\n尽量高的带宽。', '0');
INSERT INTO `question_answer` VALUES ('272', '何谓存储器页面锁定功能?', '存储器页面锁定功能是用户自主临时隐藏已发布内容，停止接收互动信息的操作。页面锁定后，用户的所有资源将对其他人不可见，存储器页面将隐藏已发布内容。', '0');
INSERT INTO `question_answer` VALUES ('273', '存储器代理的主要任务是什么?', '接受用户从终端上键入的字符、字符缓冲 用于暂存所接收的字符、回送显示、屏幕编辑、特殊字符处理等', '0');
INSERT INTO `question_answer` VALUES ('274', '媒体服务器接纳控制的主要任务是什么?', '主要任务是确定任何新的请求能否被接纳，而不影响正在被处理的请求。', '0');
INSERT INTO `question_answer` VALUES ('275', '为了满足不同用户的需要,媒体服务器可以提供哪几种服务质量保证?', '确定型的保证、统计型的保证、尽力而为型保证', '0');
INSERT INTO `question_answer` VALUES ('276', '把多媒体文件存放在硬盘上时,为什么要采取交叉连续存放方式?', '常在一部数字电影中每一帧都同时包含了视频、音频和文字信息即使其中的每一种媒体文件都独立存在也应该采取交叉连续存放方式。', '0');
INSERT INTO `question_answer` VALUES ('277', '某文件系统文件存储采用文件索引节点法。假设文件索引节点中有8个地址项iaddr[0]～iaddr[7]，每个地址项大小为4字节，其中地址项iaddr[0]～iaddr[5]为直接地址索引，iaddr[6]是一级间接地址索引，iaddr[7]是二级间接地址索引，磁盘索引块和磁盘数据块大小均为4KB。该文件系统可表示的单个文件最大长度是（7）KB。若要访问iclsClient.dll文件的逻辑块号分别为6、520和1030，则系统应分别采用（8）？', '磁盘索引块为4KB字节，每个地址项大小为4字节，故每个磁盘索引块可存放4K/4=1024个物理地址块。\r\n0-5存放6个物理块号\r\n一级存放1024(每个磁盘索引块可存放4K/4=1024个物理地址块)\r\n二级为 1024*1024 磁盘数据块大小为4K\r\n(6+1024+1024*1024)*4k=4198424\r\n逻辑块号从0开始,所以6是大于0~5不属于直接索引,所以为1级索引\r\n1级索引逻辑块号范围6~(6+1024-1)=6~1029\r\n所以520为1级 1030为2级', '0');
INSERT INTO `question_answer` VALUES ('278', '设文件索引结点中有8个地址项，每个地址项大小为4字节，其中5个地址项为直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接地址索引，磁盘索引块和磁盘数据块大小均为1KB。则可表示的单个文件最大长度是多少KB？', '磁盘索引块为1KB字节，每个地址项大小为4字节，故每个磁盘索引块可存放1024/4=256个物理地址块。又因为文件索引节点中有8个地址项，其中5个地址项为直接地址索引，这意味着逻辑块号为0—4的为直接地址索引；2个地址项是一级间接地址索引，这意味着第一个地址项指出的物理块中存放逻辑块号为5—260的物理块号，第二个地址项指出的物理块中存放逻辑块号为261—516的物理块号；1个地址项是二级间接地址索引，该地址项指出的物理块存放了256个间接索引表的地址，这256个间接索引表存放逻辑块号为517—66052的物理块号（256*256=65536个）。单个文件的逻辑块号范围是0—66052，而磁盘数据块大小为1KB，所以单个文件最大长度为：66053KB。', '0');
INSERT INTO `question_answer` VALUES ('279', '什么是近似视频点播?近似视频点播的文件应如何存放?', '近似视频点播是规则点播的一种近似，它是每隔一段时间开始一次播放', '0');
INSERT INTO `question_answer` VALUES ('280', '什么是视频流?', '视频流是指视频数据的传输，例如，它能够被作为一个稳定的和连续的流通过网络处理。因为流动，客户机浏览器或插件能够在整个文件被传输完成前显示多媒体数据。视频流技术基于 2 密钥技术，视频译码技术和可升级的视频分发技术发展。', '0');
INSERT INTO `question_answer` VALUES ('281', '什么是Zipf定律?', 'Zipf定律可以表述为在自然语言的语料库里，一个单词出现的次数与它在频率表里的排名成反比。Zipf定律是美国学者G.K.齐普夫1935年提出的。', '0');
INSERT INTO `question_answer` VALUES ('282', '高速缓存在多媒体系统中可有哪些用处?', '高速缓存在多媒体系统中可以起到及时备份数据、增大容量、加快速度、稳定传输的作用。\r\n高速缓存在多媒体系统中可以起到及时备份数据、增大容量、加快速度、稳定传输的作用。\r\n高速缓存在多媒体系统中可以起到及时备份数据、增大容量、加快速度、稳定传输的作用。', '0');
INSERT INTO `question_answer` VALUES ('283', '磁臂调度算法分类？', '先来先服务，最短寻道时间优先，电梯调度算法，循环扫描算法', '0');
INSERT INTO `question_answer` VALUES ('284', '为什么需要磁盘调度算法？', '移动磁头到指定磁道上—寻道时间，等待磁盘旋转，直到需要读写的扇区在磁头下面—旋转延迟时间，传输数据—把数据从磁盘读出或写入，其中前两者的耗时比较长，磁盘调度问题的目的是减少寻道时间。', '0');
INSERT INTO `question_answer` VALUES ('285', '为什么要讲文件以及磁盘的关系呢？', '我们说文件是对磁盘的抽象，其实是一种底层思维，磁盘的基本属性是保存信息、数据，那么提供一个抽象层或多个抽象层的目的是方便使用。同理，我们在各个领域遇到这种情况也可以借鉴这里的思路：提供一层或多层抽象，从而由不易使用到容易使用。', '0');
INSERT INTO `question_answer` VALUES ('286', '系统安全性的主要目标是什么?', '操作系统安全性的主要目标是方便人机交互。', '0');
INSERT INTO `question_answer` VALUES ('287', '系统安全性的复杂性表现在哪几个方面?', '系统安全性的复杂性表现在应用复杂、结构复杂、结果复杂、过程复杂等。', '0');
INSERT INTO `question_answer` VALUES ('288', '对系统安全性的威胁有哪几种类型?', '内部威胁，包括系统自身的漏洞，计算机硬件的突发故障等\r\n外部威胁，包括网络上的病毒，网络上的恶意攻击等', '0');
INSERT INTO `question_answer` VALUES ('289', '可信任计算机系统评价标准将计算机系统的安全度分为哪几个等级?', '7个级别。分别是D1 C1 C2 B1 B2 B3 A。', '0');
INSERT INTO `question_answer` VALUES ('290', '何谓对称加密算法和非对称加密算法?', '对称加密算法是加密和解密时使用相同的密钥，主要用于保证数据的机密性。非对称加密算法也叫公开密钥算法，其加密和解密是相对独立的，使用不同的密钥。', '0');
INSERT INTO `question_answer` VALUES ('291', '什么是易位法和置换算法?', '易位法是按照一定的规则，重新安排明文中的比特或字符的顺序来形成密文，而字符本身保持不变。\r\n置换算法是按照一定的规则，用一个字符去置换另一个字符来形成密文。', '0');
INSERT INTO `question_answer` VALUES ('292', '非对称加密算法的主要特点是什么?', '算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密接得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了这样安全性就大了很多。', '0');
INSERT INTO `question_answer` VALUES ('293', '保密数据签名的加密和解密方式是什么? ', '它使用一对数学上相关的钥匙，其中一个(公钥)用来加密信息，另一个(私钥)用来解密信息。PGP采用的传统加密技术部分所使用的密钥称为\"会话密钥\"(sek)。每次使用时，PGP都随机产生一个128位的IDEA会话密钥，用来加密报文。公开密钥加密技术中的公钥和私钥则用来加密会话密钥，并通过它间接地保护报文内容。', '0');
INSERT INTO `question_answer` VALUES ('294', '数字证明书的作用是什么? ', '信息的保密性、交易者身份的确定性、不可否认性、不可修改性 \r\n数字安全证书提供了一种在网上验证身份的方式。安全证书体制主要采用了公开密钥体制，其它还包括对称密钥加密、数字签名、数字信封等技术。', '0');
INSERT INTO `question_answer` VALUES ('295', '可利用哪几种方式来确定用户身份的真实性?', '加密技术、认证技术和电子安全协议等。', '0');
INSERT INTO `question_answer` VALUES ('296', '在基于口令机制的认证技术中,通常应满足哪些要求?', '口令长度适中，口令内容不能过于单一。', '0');
INSERT INTO `question_answer` VALUES ('297', '基于物理标志的认证技术又可细分为哪几种?', '基于磁卡的认证技术和基于IC卡的认证技术', '0');
INSERT INTO `question_answer` VALUES ('298', '智能卡可分为哪几种类型?', '金融卡、非金融卡、交通卡、政府应用卡', '0');
INSERT INTO `question_answer` VALUES ('299', '被选用的生理标志应具有哪几个条件? ', '应具有足够的可变性。', '0');
INSERT INTO `question_answer` VALUES ('300', '对生物识别系统的要求有哪些?一个生物识别系统通常是由哪几部分组成?', '生物识别系统通常由离线注册部分和在线识别部分组成。', '0');
INSERT INTO `question_answer` VALUES ('301', '早期常采用的内部攻击方式有哪几种?', '窃取尚未清除的有用信息', '0');
INSERT INTO `question_answer` VALUES ('302', '何谓逻辑炸弹?较常用的引爆条件有哪些?', '“逻辑炸弹”是指在特定逻辑条件满足时，实施破坏的计算机程序，该程序触发后造成计算机数据丢失、计算机不能从硬盘或软盘引导，甚至会使整个系统瘫痪，并出现物理损坏的虚假现象。\r\n较常用的引爆条件有事件触发、事件触发、计数器触发等', '0');
INSERT INTO `question_answer` VALUES ('303', '何谓陷阱门和特洛伊木马?', '陷阱门其实就是一段代码，是进入一个程序的隐蔽入口点。\r\n特洛伊木马是一种基于远程控制的黑客工具，具有很强的隐蔽性和危害性。', '0');
INSERT INTO `question_answer` VALUES ('304', '何谓缓冲区溢出?', '是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。', '0');
INSERT INTO `question_answer` VALUES ('305', '什么是病毒和蠕虫? ', '蠕虫病毒是一种常见的计算机病毒。它是利用网络进行复制和传播，传染途径是通过网络和电子邮件。最初的蠕虫病毒定义是因为在DOS环境下，病毒发作时会在屏幕上出现一条类似虫子的东西，胡乱吞吃屏幕上的字母并将其改形。', '0');
INSERT INTO `question_answer` VALUES ('306', '什么是移动代码? 为什么说在应用程序中包含了移动代码就可能不安全?', '如果一个程序在运行时，能在不同机器之间来回迁移，那么该程序就被称为移动代码。在应用程序中可移动变量会导致程序出错。', '0');
INSERT INTO `question_answer` VALUES ('307', '计算机病毒的特征是什么?', '计算机病毒具有传播性、隐蔽性、感染性、潜伏性、可激发性、表现性或破坏性的特点。', '0');
INSERT INTO `question_answer` VALUES ('308', '计算机病毒有哪几种类型? ', '系统病毒、蠕虫病毒、木马病毒、脚本病毒、宏病毒、后门病毒、病毒种植程序病毒、破坏性程序病毒、玩笑病毒、捆绑机病毒。', '0');
INSERT INTO `question_answer` VALUES ('309', '什么是文件型病毒? ', '文件型病毒系计算机病毒的一种，主要通过感染计算机中的可执行文件(.exe)和命令文件(.com)。文件型病毒是对计算机的源文件进行修改，使其成为新的带毒文件。一旦计算机运行该文件就会被感染，从而达到传播的目的。', '0');
INSERT INTO `question_answer` VALUES ('310', '病毒设计者采取了哪几种隐藏方式来让病毒逃避检测?', '(1)隐藏于目录和注册表空间 (2)隐藏于程序的页内零头里。\r\n(3)更改用于磁盘分配的数据结构(4)更改坏扇区列表。', '0');
INSERT INTO `question_answer` VALUES ('311', '用户可采用哪些方法来预防病毒?', '(1)定期在外存备份重要软件和数据 (2)使用安全性高的操作系统(3)使用正版软件 (4)使用高性能反病毒软件(5) 不轻易打开来历不明的电子邮件 (6)定期检查外存并清除病毒', '0');
INSERT INTO `question_answer` VALUES ('312', '基于病毒数据库的病毒检测方法是什么?', '(1)建立病毒数据库 (2)扫描硬盘上的可执行文件', '0');

-- ----------------------------
-- Table structure for teacher
-- ----------------------------
DROP TABLE IF EXISTS `teacher`;
CREATE TABLE `teacher` (
  `tid` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) NOT NULL,
  `password` varchar(32) NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `telephone` varchar(11) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '激活状态：0-未激活  1-已激活',
  `code` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`tid`),
  UNIQUE KEY `AK_nq_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of teacher
-- ----------------------------

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `uid` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) NOT NULL,
  `password` varchar(32) NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `sex` char(1) DEFAULT NULL,
  `telephone` varchar(11) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `status` tinyint(2) NOT NULL DEFAULT '0' COMMENT '激活状态：0-未激活  1-已激活',
  `code` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  UNIQUE KEY `AK_nq_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
